<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Константы</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../1.css">
<script type="text/javascript" src="../1.js"></script>
</head>
<body>

<h3>Константы WebGLRenderer</h3>

<h4 id="cullFaceModes">Режимы выбраковки граней (cull face modes)</h4>
<pre><span class="lnk" onmouseover="show('cull face none - нет выбраковки граней');" onmouseout="hide()">THREE.CullFaceNone</span>
<span class="lnk" onmouseover="show('cull face back - отбрасывается задняя грань');" onmouseout="hide()">THREE.CullFaceBack</span>
<span class="lnk" onmouseover="show('cull face front - отбрасывается передняя грань');" onmouseout="hide()">THREE.CullFaceFront</span>
<span class="lnk" onmouseover="show('cull face front back - отбрасываются грани впереди и сзади');" onmouseout="hide()">THREE.CullFaceFrontBack</span></pre>
<div class=list><span class="lnk" onmouseover="show(type_const);" onmouseout="hide()">CullFaceNone</span> отключает выбраковку граней.</div>
<div class=list><span class="lnk" onmouseover="show(type_const);" onmouseout="hide()">CullFaceBack</span> отбрасываются задние грани (эта константа применяется по умолчанию).</div>
<div class=list><span class="lnk" onmouseover="show(type_const);" onmouseout="hide()">CullFaceFront</span> отбрасываются передние грани.</div>
<div class=list><span class="lnk" onmouseover="show(type_const);" onmouseout="hide()">CullFaceFrontBack</span> отбрасываются обе грани, и передняя и задняя.</div><br>

<h4 id="frontFaceDirection">Направление передней грани (front face direction)</h4>
<pre><span class="lnk" onmouseover="show('сокращение от front face direction clockwise - направление передних граней по часовой стрелке');" onmouseout="hide()">THREE.FrontFaceDirectionCW</span>
<span class="lnk" onmouseover="show('сокращение от front face direction counter-clockwise - направление передних граней против часовой стрелки');" onmouseout="hide()">THREE.FrontFaceDirectionCCW</span></pre>
<div class=list><span class="lnk" onmouseover="show(type_const);" onmouseout="hide()">FrontFaceDirectionCW</span> устанавливает порядок следования многоугольников (полигонов) по часовой стрелке.</div>
<div class=list><span class="lnk" onmouseover="show(type_const);" onmouseout="hide()">FrontFaceDirectionCCW</span> устанавливает порядок следования многоугольников (полигонов) против часовой стрелки (значение по умолчанию).</div><br>

<h4 id="shadowTypes">Типы тени (shadow types)</h4>
<pre><span class="lnk" onmouseover="show('basic shadow map - базовая карта тени');" onmouseout="hide()">THREE.BasicShadowMap</span>
<span class="lnk" onmouseover="show('PCF shadow map - карта тени с фильтром процентного приближения - PCF');" onmouseout="hide()">THREE.PCFShadowMap</span>
<span class="lnk" onmouseover="show('PCF soft shadow map - карта мягкой тени с фильтром процентного приближения');" onmouseout="hide()">THREE.PCFSoftShadowMap</span>
<span class="lnk" onmouseover="show('VSM shadow map - карта тени с фильтром<br>по алгоритму VSM (variance shadow map),<br>т.е. разностная карта тени.');" onmouseout="hide()">THREE.VSMShadowMap</span></pre>
Эти константы определяют свойство <a href="../renderers/webGLRenderer.htm#shadowMap.type" onmouseover="show('WebGLRenderer.shadowMap.type');" onmouseout="hide()">shadowMap.type</a> WebGLRenderer'а.

<div class=list><span class="lnk" onmouseover="show('basic shadow map - базовая карта тени<br><br>'+type_const)" onmouseout="hide()">BasicShadowMap</span> дает нефильтрованные карты теней - самые быстрые, но и самые низкокачественные.</div>
<div class=list><span class="lnk" onmouseover="show('Работа алгоритма заключается в том, что производится несколько<br>тестов на затенение в окрестностях искомого фрагмента и для<br>затенения используется среднее значение этих тестов, таким<br>образом, граница тени будет более «мягкой».<br><br>'+type_const)" onmouseout="hide()">PCFShadowMap</span> фильтрует теневые карты по алгоритму Percentage-Closer Filtering - PCF (значение по умолчанию).</div>
<div class=list><span class="lnk" onmouseover="show('Технология создания теней PCSS позволяет сделать их более<br>реалистичными и приближенными к жизни. Очертания теней<br>растворяются по мере удаления от объекта, отбрасывающего<br>тень. Использование технологии PCSS позволяет сделать<br>очертания теней естественными и избежать «лесенок», т.е. алиасинга.<br><br>'+type_const)" onmouseout="hide()">PCFSoftShadowMap</a></span> фильтрует теневые карты по алгоритму Percentage-Closer Soft Shadows (PCSS).</div>
<div class=list><span class="lnk" onmouseover="show('VSM shadow map - карта тени с фильтром<br>по алгоритму VSM (variance shadow map),<br>т.е. разностная карта тени.<br><br>'+type_const)" onmouseout="hide()">VSMShadowMap</span> фильтрует теневые карты при помощи алгоритма Variance Shadow Map (VSM), т.е. посредством разностных карт теней.
При использования алгоритма VSMShadowMap все объекты, принимающие тень, также и отбрасывают её.
<div class=note_trans><b>Примечание переводчика:</b> Разностные карты теней (Variance Shadow Maps - VSM) – это алгоритм, исправляющий ошибку <span class="lnk" onmouseover="show('Алиасинг (от англ. слова aliasing - эффект наложения, ступенчатость,<br>зубчатость) в компьютерной графике — эффект &#171;ступенчатости&#187;<br>изображения, против которого используются различные алгоритмы<br>сглаживания.')" onmouseout="hide()">алиасинга</span> путем дополнительной фильтрации.
Принцип действия VSM основан на алгоритме PCF (Percentage-closer filtering), но улучшает его за счет выполнения фильтрации непосредственно на самой карте теней: пишется шейдер для формирования специальной многоканальной карты теней,
в которой сохраняется значения глубины пикселя и квадрата глубины пикселя (при этом используется буфер значений с плавающей запятой), далее происходит фильтрация карты
(например, <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80_%D0%93%D0%B0%D1%83%D1%81%D1%81%D0%B0" target="_blank">размытие по Гауссу</a>), находится среднее значение глубины и среднеквадратическое отклонение;
далее проводиться стандартный тест глубины, и, если в результате оказывается, что точка находиться в тени, ей присваивается значение выведенное из неравенства Чебышева (а не значение единицы как в SSMs).<br>
Преимущество метода заключается в том, что VSM-буфер можно предварительно отфильтровать один раз, и затем использовать для дальнейшего рендеринга без PCF, значительно повышая тем самым производительность.
Недостатки – обязательное наличие многоканальной текстуры для хранения данных и ошибки приближения при возведении значения глубины в квадрат, самая серьезная из которых - так называемый <span class="lnk" onmouseover="show('light-bleeding - оцените перевод,<br>можно перевести как &#171;просачивание света&#187;,<br>а можно как &#171;легкое кровотечение&#187;')" onmouseout="hide()">light-bleeding</span>,
когда в зоне затенения появляются светлые пятна. Есть несколько способов исправления данной проблемы, но они либо требуют больше памяти, либо делают тени не такими мягкими, как хотелось бы.</div></div><br>

<h4 id="toneMapping">Отображение тона цвета (tone mapping)</h4>
<div class=note_trans>
HDR (High Dynamic Range) — технология широкодиапазонного представления цвета.<a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>До недавнего времени стандартно цвет в компьютерной графике представлялся 32 битами, по 8 бит на компонент (красный, зелёный, синий и альфа). Таким образом, каждая цветовая компонента может принимать 256 различных оттенков. Практика показала, что при таком количестве оттенков человеческий глаз не способен различить погрешности отображения. Проще говоря, такой точности хватало.<br>
Однако теперь, в связи с появлением более сложных технологий освещения, появилась необходимость большей точности вычислений. В результате появилась технология HDR. Суть её заключается в использовании 16 бит на компонент (исключение составляет только самый конец конвейера — экран, где используется по-прежнему 8-битная точность, для реализации эффекта HDR применяют 16-битные текстуры специального формата). Кроме того, яркость компонента представляется не числом с фиксированной точкой, а с плавающей, в результате чего появляется возможность работать с очень большими и очень малыми значениями при довольно высокой точности. В итоге, становится возможным работать с такими эффектами, как световые блики, ослепление ярким светом и пр.<br>
Чаще всего термин HDR употребляется в отношении получения, хранения и обработки растровых изображений. Широко используемые на сегодняшний день цифровые технологии исторически основаны на 8-битных целочисленных форматах представления и обработки данных, что даёт весьма узкий динамический диапазон, часто называемый SDR (англ. Standard Dynamic Range) или LDR (англ. Low Dynamic Range). Для сравнения, отношение наиболее яркого к наименее яркому (но ещё не чёрному) цветам для sRGB составляет порядка 3 000:1, в то время как реальные сцены часто имеют динамический диапазон яркости в 1 000 000:1 и выше, при этом и в тенях и в свете глаз способен (из-за световой адаптации к яркости) различить детали. Применение техники HDR позволяет работать с полным диапазоном яркости сцены, устраняя исторические ограничения.</div></div>
Отображение тонов цвета (tone mapping) - это процесс преобразования диапазона яркостей HDR к LDR диапазону, отображаемому устройством вывода, например, монитором или принтером,
так как вывод HDR изображений на них потребует преобразования динамического диапазона и цветового охвата модели HDR в соответствующий динамический диапазон LDR, чаще всего модель RGB.
Ведь диапазон яркости, представленный в HDR, очень широк, это несколько порядков абсолютного динамического диапазона единовременно, в одной сцене.
А диапазон, который можно воспроизвести на привычных устройствах вывода (мониторах, телевизорах), составляет лишь около двух порядков динамического диапазона.<br>
Преобразование из HDR в LDR и называется <span class="lnk" onmouseover="show('тональное отображение (англ. tone mapping), при котором<br>закон преобразования яркости пикселей может быть разным<br>для различных частей изображения (имитация градиентного<br>фильтра). Существуют разные алгоритмы с разными<br>дополнительными эффектами и возможностями по управлению<br>пользователем этим процессом. В результате применения<br>алгоритмов могут образовываться ореолы в районе границ<br>между светлыми и тёмными областями, тёмные по природе<br>объекты могут стать неестественно светлыми.')" onmouseout="hide()">отображением тонов (tone mapping)</span>,
оно выполняется с потерями и имитирует свойства человеческого зрения.
<pre><span onclick="showClick(type_const)"><a href="#" onclick="return false" onblur="hideClick()" onmouseover="show('no tone mapping - нет отображения тонов');" onmouseout="hide()">THREE.NoToneMapping</a></span>
<span onclick="showClick(type_const)"><a href="#" onclick="return false" onblur="hideClick()" onmouseover="show('linear tone mapping - линейное преобразование отображения тонов');" onmouseout="hide()">THREE.LinearToneMapping</a></span>
<span onclick="showClick(type_const)"><a href="#" onclick="return false" onblur="hideClick()" onmouseover="show('Reinhard tone mapping - преобразование отображения тонов по Рейнгарду');" onmouseout="hide()">THREE.ReinhardToneMapping</a></span>
<span onclick="showClick(type_const)"><a href="#" onclick="return false" onblur="hideClick()" onmouseover="show('uncharted 2 tone mapping - uncharted 2 отображение тонов');" onmouseout="hide()">THREE.Uncharted2ToneMapping</a></span>
<span onclick="showClick(type_const)"><a href="#" onclick="return false" onblur="hideClick()" onmouseover="show('cineon tone mapping - преобразование cineon отображения тонов');" onmouseout="hide()">THREE.CineonToneMapping</a></span>
<span onclick="showClick(type_const)"><a href="#" onclick="return false" onblur="hideClick()" onmouseover="show('ACES filmic tone mapping - система кодирования цвета ACES была<br>разработана для бесшовной работы с цветными изображениями независимо<br>от входного или выходного цветового пространства. Она также имеет<br>тщательно продуманную кинематографическую кривую для отображения<br>изображений HDR на устройствах вывода LDR.');" onmouseout="hide()">THREE.ACESFilmicToneMapping</a></span></pre>
Эти константы определяют свойство <a href="../renderers/webGLRenderer.htm#toneMapping" onmouseover="show('WebGLRenderer.toneMapping');" onmouseout="hide()">toneMapping</a> WebGLRenderer'а.
Они используются для приведения внешнего вида изображения в расширенном динамическом диапазоне (high dynamic range - HDR) к возможному отображению их в низком динамическом диапазоне (low dynamic range - LDR) стандартного компьютерного монитора или экрана мобильного устройства.<br>
<span onclick="showClick(type_const)"><a href="#" onclick="return false" onblur="hideClick()" onmouseover="show('no tone mapping - нет отображения тонов');" onmouseout="hide()">NoToneMapping</a></span> отключает отображение тонов.<br>
Значением по умолчанию является <span onclick="showClick(type_const)"><a href="#" onclick="return false" onblur="hideClick()" onmouseover="show('linear tone mapping - линейное отображение тонов');" onmouseout="hide()">LinearToneMapping</a></span>.<br>
Смотрите пример <a href="https://threejs.org/examples/webgl_tonemapping" target="_blank">отображения тонов</a>.<br><br>

<h4>Исходники</h4>
<div class=blockindent><a href="https://github.com/mrdoob/three.js/blob/master/src/constants.js" target="_blank">constants.js на github.com</a></div><br>

<br><br>
</body></html>