<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Three.js</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>
<body>
<h2 class=head1>Система координат</h2>
<div class=below><div class=note_trans><b>Примечание переводчика:</b> На мой взгляд это очень важный вопрос и жаль, что его нет в оригинальной документации по <em>three.js</em>.
Поэтому, вначале приводится описание системы координат из книги &#171;WebGL: программирование трехмерной графики&#187; авторов Коичи Мацуда (Kouichi Matsuda) и Роджер Ли (Rodger Lea),
а потом более простое и может быть, более понятное описание от <a href="https://github.com/kolosov-sergey" target="_blank">Сергея Колосова</a>, размещенное на <a href="https://devburn.ru/2015/07/25/%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82%D1%8B/" target="_blank">devburn.ru</a>.</div>
<div class=list><a href="#1">Система координат элемента HTML <tt>&lt;canvas&gt;</tt></a></div>
<div class=list><a href="#2">Система координат WebGL</a></div>
<div class=list><a href="#3">ПРИЛОЖЕНИЕ D. WebGL/OpenGL: лево- или правосторонняя система координат?</a></div>
<div class=list><a href="#4">ПРИЛОЖЕНИЕ G. Мировая и локальная системы координат</a></div>
<div class=list><a href="#5">И ещё о координатах...</a> (от <a href="https://github.com/kolosov-sergey" target="_blank">Сергея Колосова</a>)</div></div><br>

<h3 id="1">Система координат элемента HTML <tt>&lt;canvas&gt;</tt></h3>
Рассмотрим систему координат, используемую элементом <tt>&lt;canvas&gt;</tt> (см. рис. 2.5) с шириной и высотой по <tt>400</tt> пикселей, на котором нарисован квадрат <tt>150&#215;150</tt> с начальной точкой <tt>x=120</tt>, <tt>y=10</tt>.
<div class="caption"><img src="img/coord_canvas.png" width=400><br>
Рис. 2.5. Система координат элемента <tt>&lt;canvas&gt;</tt></div><br>
Как видите, начало системы координат элемента <tt>&lt;canvas&gt;</tt> находится в верхнем левом углу, ось <tt>X</tt> определяет координату по горизонтали (слева направо), а ось <tt>Y</tt> – координату по вертикали (сверху вниз).
Пунктирная линия показывает границы области рисования, определяемой элементом <tt>&lt;canvas&gt;</tt>, размером <tt>400</tt> на <tt>400</tt> пикселей. Линия из точек – это границы квадрата <tt>150&#215;150</tt>, который рисует программа.<br><br>

<h3 id="2">Система координат WebGL</h3>
Поскольку система WebGL работает с трехмерной графикой, она использует трехмерную систему координат с тремя осями: <tt>X</tt>, <tt>Y</tt> и <tt>Z</tt>.
Эта система координат проста и понятна, потому что окружающий нас мир тоже имеет три измерения: ширину (<tt>X</tt>), высоту (<tt>Y</tt>) и глубину(<tt>Z</tt>). В любой системе координат направление осей играет важную роль.
<table align=center><tr><td><div class="caption"><img src="img/coord_WebGL1.png" width=600><br>Рис. 2.16. Система координат в WebGL</div></td>
<td><div class="caption"><img src="img/coord_right.png" width=220><br>
Рис. 2.17. Правосторонняя система координат</div></td></tr></table><br>

Вообще, в WebGL, когда вы сидите перед плоскостью экрана монитора, ось <tt>X</tt> простирается по горизонтали, (слева направо), ось <tt>Y</tt> – по вертикали (снизу вверх) и ось <tt>Z</tt> – в направлении от плоскости экрана к пользователю (слева на рис. 2.16).
Глаз пользователя находится в начале координат <tt>(0.0, 0.0, 0.0)</tt> и смотрит вдоль оси <tt>Z</tt>, в сторону отрицательных значений – за плоскость экрана (справа на рис. 2.16).<br>
Такая система координат называется также правосторонней, потому что ее можно изобразить пальцами правой руки (см. рис. 2.17), и она же обычно используется при работе с WebGL (то есть, она принята по умолчанию).<br>
Однако следует помнить, что в действительности все гораздо сложнее. Фактически система координат в WebGL не является ни правосторонней, ни левосторонней.
Подробнее смотрите ниже в приложении D, «<a href="#3">WebGL/OpenGL: лево- или правосторонняя система координат?</a>».<br><br>

Как вы уже знаете, область рисования, что определяется элементом <tt>&lt;canvas&gt;</tt>, имеет свою систему координат, отличную от системы координат в WebGL, поэтому необходим некоторый механизм отображения одной системы в другую.
По умолчанию, как показано на рис. 2.18, WebGL выполняет такое отображение следующим образом:
<ul><li>центр области рисования <tt>&lt;canvas&gt;</tt>: координаты <tt>(0.0, 0.0, 0.0)</tt>;</li>
<li>две вертикальные границы области рисования <tt>&lt;canvas&gt;</tt>: <tt>(–1.0, 0.0, 0.0)</tt> и <tt>(1.0, 0.0, 0.0)</tt>;</li>
<li>две горизонтальные границы области рисования <tt>&lt;canvas&gt;</tt>: <tt>(0.0, –1.0, 0.0)</tt> и <tt>(0.0, 1.0, 0.0)</tt>.</li></ul>
<div class="caption"><img src="img/coord_WebGL.png" width=400><br>
Рис. 2.18. Область рисования <tt>&lt;canvas&gt;</tt> и система координат WebGL</div><br>
(Система координат элемента <tt>&lt;canvas&gt;</tt> (Рис. 2.5) отличается от системы координат WebGL – начало системы координат и направление оси <tt>Y</tt> не совпадают.)
Как уже отмечалось, такое отображение выполняется по умолчанию. Однако, есть возможность использовать другую систему координат, о которой рассказывается ниже, но пока мы будем пользоваться системой координат по умолчанию.
Кроме того, чтобы не отвлекать ваше внимание от исследования основной функциональности WebGL, в примерах программ будут использоваться только оси <tt>X</tt> и <tt>Y</tt>. То есть, вплоть до главы 7, координата глубины (ось <tt>Z</tt>) всегда будет иметь значение <tt>0.0</tt>.<br><br>

<h3 id="3">ПРИЛОЖЕНИЕ D.<br>
WebGL/OpenGL: лево- или правосторонняя система координат?</h3>
В главе 2, «Первые шаги в WebGL», мы говорили, что система WebGL использует правостороннюю систему координат.
Однако, вам наверняка попадутся книги, статьи или другие источники информации в Веб, которые будут противоречить этому утверждению.
В данном приложении вы узнаете, какие системы координат в действительности использует WebGL и что получится, если попробовать нарисовать что-либо, используя WebGL с настройками по умолчанию.
Спецификация WebGL основана на спецификации OpenGL, поэтому все, что вы здесь узнаете, в равной степени применимо и к OpenGL.
Это приложение следует читать после знакомства с главой 7, «Вперед, в трехмерный мир», потому что здесь мы не раз будем ссылаться на примеры программ в этой главе.
Для начала обратимся к «источнику всех знаний»: к оригиналу спецификации, точнее к спецификации OpenGL ES 2.0, которая послужила основой для WebGL, и была опубликована консорциумом <a href="http://www.khronos.org/registry/gles/specs/2.0/es_cm_spec_2.0.24.pdf" target="_blank">Khronos Group</a>.
В приложении B этой спецификации отмечается:
<div class=blockindent>7. Графическая библиотека не привязана ни к левосторонней, ни к правосторонней системе координат.</div>
Если дело действительно обстоит так и WebGL не привязана к какой-то определенной системе координат, тогда почему так много книг, и эта книга в том числе, описывают WebGL, как использующую правостороннюю систему координат?
В действительности, это всего лишь соглашение. Начиная разработку своего приложения, вам необходимо решить, какая система координат будет использоваться, и придерживаться этого решения.
Это верно не только для ваших приложений, но и для библиотек, которые создаются другими разработчиками, с целью помочь другим программистам использовать WebGL (и OpenGL).
Многие из этих библиотек следуют за соглашением об использовании правосторонней системы координат,
поэтому со временем данное соглашение стало общепринятым и превратилось в синоним WebGL (и OpenGL), заставляя многих думать, что WebGL (и OpenGL) привязана к правосторонней системе координат.<br>
И что же здесь не так? Если все будут следовать за одними и теми же соглашениями, это не должно вызывать никаких проблем.
Да, это так, но возникает одна сложность, потому что WebGL (и OpenGL) иногда требуют, чтобы графическая библиотека выполняла операции без учета направленности системы координат – с настройками по умолчанию,
если хотите, – а настройки по умолчанию не всегда оказываются правосторонними!<br>
В этом приложении мы посмотрим, как действует WebGL с настройками по умолчанию, чтобы вы могли четко понять суть проблемы и как избежать неприятностей в своих приложениях.<br>
Для начала напишем программу <tt>CoordinateSystem</tt>, которая будет служить нам полигоном для экспериментов.
С помощью этой программы мы вернемся сначала к самым основам – приемам рисования треугольников – и затем будем наращивать ее возможности, исследуя, как WebGL рисует множество объектов.
В данной программе перед нами стоит цель – нарисовать синий треугольник в позиции&nbsp;<tt>–0.1</tt> на оси&nbsp;<tt>Z</tt> и красный треугольник в позиции&nbsp;<tt>–0.5</tt> на оси&nbsp;<tt>Z</tt>.

<div class="caption"><img src="img/d_1.png" width=300><br>
Рис. D.1. Треугольники, используемые в качестве примеров в этом приложении, и их цвета</div><br>
Как будет показано далее в этом приложении, чтобы достигнуть нашей относительно скромной цели, нам потребуется организовать взаимодействие множества механизмов,
включая механизм простого рисования, механизм удаления скрытых поверхностей и механизм отображения видимого объема.
Без должной настройки всех трех механизмов мы получим довольно неожиданные результаты, которые могут привести к путанице между лево- и правосторонними системами координат.
<h4>Пример программы CoordinateSystem.js</h4> 
<div>В листинге D.1 представлен исходный код программы <tt>CoordinateSystem.js</tt>.
Мы убрали из листинга код обработки ошибок и некоторые комментарии ради экономии места, однако в загружаемом пакете программ вы найдете полный исходный код. <a class='link' onclick='javascript:spoiler1(this)'>... показать</a>
<div style='display:none;'><h5>Листинг D.1. <tt>CoordinateSystem.js</tt></h5>
<pre>1 // CoordinateSystem.js
2 // Вершинный шейдер
3 var VSHADER_SOURCE =
4   ‘attribute vec4 a_Position;\n’ +
5   ‘attribute vec4 a_Color;\n’ +
6   ‘varying vec4 v_Color;\n’ +
7   ‘void main() {\n’ +
8   ‘ gl_Position = a_Position;\n’ +
9   ‘ v_Color = a_Color;\n’ +
10  ‘}\n’;
11
12 // Фрагментный шейдер
13 var FSHADER_SOURCE =
14  ‘#ifdef GL_ES\n’ +
15  ‘precision mediump float;\n’ +
16  ‘#endif\n’ +
17  ‘varying vec4 v_Color;\n’ +
18  ‘void main() {\n’ +
19  ‘ gl_FragColor = v_Color;\n’ +
20  ‘}\n’;
21
22 function main() {
23  var canvas = document.getElementById(‘webgl’); // Получить &lt;canvas&gt;
24  var gl = getWebGLContext(canvas); // Получить контекст WebGL
25  initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE);// Инициализировать шейдеры
26  var n = initVertexBuffers(gl); // Определить координаты вершин и цвета
27
28  gl.clearColor(0.0, 0.0, 0.0, 1.0); // Определить цвет очистки
29  gl.clear(gl.COLOR_BUFFER_BIT); // Очистить &lt;canvas&gt;
30  gl.drawArrays(gl.TRIANGLES, 0, n); // Нарисовать треугольники
31 }
32
33 function initVertexBuffers(gl) {
34  var pc = new Float32Array([ // Координаты вершин и цвета
35    0.0, 0.5, -0.1, 0.0, 0.0, 1.0, // Синий треугольник, ближний
36   -0.5, -0.5, -0.1, 0.0, 0.0, 1.0,
37    0.5, -0.5, -0.1, 1.0, 1.0, 0.0,
38
39    0.5, 0.4, -0.5, 1.0, 1.0, 0.0, // Красный треугольник, дальний
40   -0.5, 0.4, -0.5, 1.0, 0.0, 0.0,
41    0.0, -0.6, -0.5, 1.0, 0.0, 0.0,
42  ]);
43  var numVertex = 3; var numColor = 3; var n = 6;
44
45  // Создать буферный объект и записать в него данные
46  var pcbuffer = gl.createBuffer();
47  gl.bindBuffer(gl.ARRAY_BUFFER, pcbuffer);
48  gl.bufferData(gl.ARRAY_BUFFER, pc, gl.STATIC_DRAW);
49
50  var FSIZE = pc.BYTES_PER_ELEMENT; // Число байтов
51  var STRIDE = numVertex + numColor; // Вычислить шаг
52
53  // Присвоить координаты вершины переменной-атрибуту
54  var a_Position = gl.getAttribLocation(gl.program, ‘a_Position’);
55  gl.vertexAttribPointer(a_Position, numVertex, gl.FLOAT, false, FSIZE * STRIDE, 0);
56  gl.enableVertexAttribArray(a_Position);
57
58  // Присвоить цвета переменной-атрибуту
59  var a_Color = gl.getAttribLocation(gl.program, ‘a_Color’);
60  gl.vertexAttribPointer(a_Color, numColor, gl.FLOAT, false, FSIZE * STRIDE,
                                                           FSIZE * numVertex);
61  gl.enableVertexAttribArray(a_Color);
62
63  return n;
64 }</pre></div></div><br>
Если запустить эту программу, она создаст изображение, показанное на рис. D.2.<br>
На черно-белом рисунке это сложно увидеть (не забывайте, что вы можете запустить программу в браузере на веб-сайте книги), поэтому сразу скажу, что красный треугольник нарисован перед синим.
Это противоречит нашим ожиданиям, потому что согласно определениям координат вершин в строках с 32 по 42 синий треугольник должен быть нарисован перед красным.
<div class="caption"><img src="img/d_2.png" width=300><br>
Рис. D.2. Картинка, созданная CoordinateSystem.js</div><br>
Однако, как описывалось в главе 7, здесь нет никакой ошибки. Так получилось просто потому, что WebGL сначала нарисовала синий треугольник, потому что его координаты определены первыми, а потом красный, поверх синего.
Это немного напоминает рисование красками; нижний слой краски будет закрыт слоем краски, наносимым сверху.<br>
Многие, только начинающие осваивать WebGL, находят такое поведение противоречащим здравому смыслу.
Поскольку WebGL – это система для создания трехмерной графики, можно было бы ожидать, что она «все сделает правильно» и нарисует красный треугольник за синим.
Однако, по умолчанию WebGL рисует фигуры в том порядке, в каком они определены и не учитывает их размещение вдоль оси&nbsp;<tt>Z</tt>.
Если вам нужно, чтобы WebGL действительно «все сделала правильно», следует включить механизм Удаления Скрытых Поверхностей, обсуждавшийся в главе 7.
Как там было показано, механизм Удаления Скрытых Поверхностей помогает системе WebGL проанализировать трехмерную сцену и удалить поверхности, которые действительно не видны с данной точки наблюдения.
В нашем случае этот механизм должен помочь ликвидировать проблему отображения красного треугольника в трехмерной сцене, скрыв большую его часть за синим треугольником.<br><br>

<h4>Удаление скрытых поверхностей и усеченная система координат</h4>
Давайте включим механизм удаления скрытых поверхностей в нашей программе и посмотрим, что из этого получится. Для этого нужно вызвать функцию <tt>gl.enable(gl.DEPTH_TEST)</tt>, очистить буфер глубины и затем нарисовать треугольники. Сначала добавим следующий код в строку 27.
<pre>27 gl.enable(gl.DEPTH_TEST);</pre>
Затем изменим строку 29, как показано ниже:
<pre>29 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</pre>
Теперь мы вправе ожидать, что проблема решена, и программа нарисует красный треугольник за синим. Однако, если запустить измененную программу, вы обнаружите, что она по-прежнему рисует красный треугольник поверх синего, как показано на рис. D.3.
<div class="caption"><img src="img/d_2.png" width=300><br>
Рис. D.3. Картинка, созданная CoordinateSystem.js с включенным механизмом удаления скрытых поверхностей</div><br>
Неожиданно, но это часть таинственности, окружающей направленность системы координат WebGL. Мы правильно реализовали нашу программу, исходя из предположения, что WebGL использует правостороннюю систему координат.
Но, похоже, что в системе координат WebGL точка с координатой&nbsp;<tt>–0.5</tt> на оси&nbsp;<tt>Z</tt> находится перед точкой с координатой&nbsp;<tt>–0.1</tt>,
либо в действительности WebGL использует левостороннюю систему координат, в которой положительное направление оси&nbsp;<tt>Z</tt> простирается от пользователя за плоскость экрана (рис. D.4).<br><br>

<h4>Усеченная система координат и видимый объем</h4>
Итак, наше приложение следует за соглашением об использовании правосторонней системы координат, но оно наглядно демонстрирует, что в действительности используется левосторонняя система координат. Как это объяснить?
Фактически, когда включается механизм удаления скрытых поверхностей, в действие вступает усеченная система координат (clip coordinate system) (см. <a href="#g5" onmouseover="show('Рис. G.5. Преобразования и системы координат')" onmouseout="hide()">рис. G.5</a> в <a href="#4" onmouseover="show('ПРИЛОЖЕНИЕ G. Мировая и локальная системы координат')" onmouseout="hide()">приложении G</a>), которая сама по себе является левосторонней.
<div class="caption"><img src="img/d_4.png" width=320><br>
Рис. D.4. Левосторонняя система координат</div><br>
В WebGL (OpenGL) удаление скрытых поверхностей выполняется с использованием значения <tt>gl_Position</tt> – координат, которые определяются вершинным шейдером.
Как можно видеть в листинге D.1 (строка 8), вершинный шейдер просто присваивает <tt>a_Position</tt> переменной <tt>gl_Position</tt>.
Это означает, что координата&nbsp;<tt>Z</tt> красного треугольника передается как&nbsp;<tt>–0.5</tt>, а координата&nbsp;<tt>Z</tt> красного треугольника передается как&nbsp;<tt>–0.1</tt> в усеченной системе координат (левосторонней).
Как вы уже знаете, положительное направление оси&nbsp;<tt>Z</tt> в левосторонней системе координат направлено за плоскость экрана, поэтому меньшая координата&nbsp;<tt>Z</tt> (<tt>–0.5</tt>) оказывается ближе к наблюдателю, чем большая координата (<tt>–0.1</tt>).
Соответственно система WebGL все сделала правильно, нарисовав красный треугольник перед синим.<br>
Совершенно очевидно, что такое поведение противоречит описанию в главе 3 (где утверждалось, что WebGL использует правостороннюю систему координат).
Так как же нам добиться нашей цели и отобразить красный треугольник за синим, и как полученные нами результаты соотносятся с поведением системы WebGL по умолчанию?
До сих пор в этой программе мы никак не учитывали видимый объем, который обязательно нужно настроить при использовании механизма удаления скрытых поверхностей.
Настройка заключается в определении ближней и дальней плоскостей отсечения, причем ближняя плоскость должна находиться перед дальней (то есть, должно выполняться условие <tt>near &lt; far</tt>).
Здесь <tt>near</tt> и <tt>far</tt> – это расстояния от точки наблюдения вдоль линии взгляда и могут иметь любые значения.
Соответственно в качестве расстояния <tt>far</tt> можно указать меньшее значение, чем значение <tt>near</tt>, или даже использовать отрицательное значение.
(Отрицательные значения интерпретируются как расстояние от точки наблюдения в направлении, противоположном направлению взгляда.)
Очевидно, что значения, выбираемые для <tt>near</tt> и <tt>far</tt>, зависят от используемой системы координат – лево- или правосторонней.
<div>Но, вернемся к примеру программы и попробуем правильно настроить видимый объем, чтобы добиться желаемого результата от механизма удаления скрытых поверхностей. В листинге D.2 приводятся только отличия от <tt>CoordinateSystem.js</tt>. <a class='link' onclick='javascript:spoiler1(this)'>... показать</a>
<div style='display:none;'><h5>Листинг D.2. <tt>CoordinateSystem_viewVolume.js</tt></h5>
<pre>1 // CoordinateSystem_viewVolume.js
2 // Вершинный шейдер
3 var VSHADER_SOURCE =
4 ‘attribute vec4 a_Position;\n’ +
5 ‘attribute vec4 a_Color;\n’ +
6 ‘uniform mat4 u_MvpMatrix;\n’ +
7 ‘varying vec4 v_Color;\n’ +
8 ‘void main() {\n’ +
9 ‘ gl_Position = u_MvpMatrix * a_Position;\n’ +
10 ‘ v_Color = a_Color;\n’ +
11 ‘}\n’;
...
23 function main() {
...
29 gl.enable(gl.DEPTH_TEST); // Включить удаление скрытых поверхностей
30 gl.clearColor(0.0, 0.0, 0.0, 1.0); // Определить цвет очистки
31 // Получить ссылку на u_MvpMatrix456 Приложение D
32 var u_MvpMatrix = gl.getUniformLocation(gl.program, ‘u_MvpMatrix’);
33
34 var mvpMatrix = new Matrix4();
35 mvpMatrix.setOrtho(-1, 1, -1, 1, 0, 1); // Определить видимый объем
36 // Передать матрицу вида в u_MvpMatrix
37 gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
38
39 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
40 gl.drawArrays(gl.TRIANGLES, 0, n); // Нарисовать треугольники
41 }</pre></div></div><br>
Если запустить эту программу, на экране появится изображение, показанное на
рис. D.5, где синий треугольник нарисован перед красным.
<div class="caption"><img src="img/d_5.png" width=400><br>
Рис. D.5. CoordinateSystem_viewVolume</div><br>

Важнейшим отличием этой версии программы является добавление в вершинный шейдер uniform-переменной (<tt>u_MvpMatrix</tt>) для передачи матрицы вида.
Она умножается на вектор координат <tt>a_Position</tt> и результат присваивается переменной <tt>gl_Position</tt>.
Хотя в данном примере для определения видимого объема мы использовали метод <tt>setOrtho()</tt>, метод <tt>setPerspective()</tt> даст тот же результат.

<h4>Теперь все правильно?</h4>
Давайте сравним вершинные шейдеры в программах <tt>CoordinateSystem.js</tt> и <tt>CoordinateSystem_viewVolume.js</tt>.<br>
Строка 8 в <tt>CoordinateSystem.js</tt>:
<pre>8 ‘ gl_Position = a_Position;\n’ +</pre>
превратилась в строку 9 в <tt>CoordinateSystem_viewVolume.js</tt>:
<pre>9 ‘ gl_Position = u_MvpMatrix * a_Position;\n’ +</pre>
Как видите, в программе <tt>CoordinateSystem_viewVolume.js</tt>, которая отображает треугольники в требуемом нам порядке, матрица преобразований (в данном случае матрица вида) умножается на координаты вершины.
Чтобы понять суть этой операции, посмотрим, как можно переписать строку 8 в программе <tt>CoordinateSystem.js</tt>
в форме <tt>&lt;матрица&gt;*&lt;координаты вершины&gt;</tt>, по аналогии со строкой 9 в программе <tt>CoordinateSystem_viewVolume.js</tt>.<br>
Строка 8 присваивает координаты вершины (<tt>a_Position</tt>) переменной <tt>gl_Position</tt> без каких-либо промежуточных преобразований.
Чтобы гарантировать, что добавление операции умножения матрицы не окажет никакого влияния, <tt>&lt;матрица&gt;</tt> должна иметь следующие элементы (то есть, она должна быть единичной матрицей):
<table align=center style="border-style:solid; border-width:1px; border-color:inherit; border-top-color:transparent; border-bottom-color:transparent; padding-left:0px; padding-right:10px;"><tr><td><pre>
1  0  0  0
0  1  0  0
0  0  1  0
0  0  0  1</pre></td></tr></table>
То есть, строка 8 в <tt>CoordinateSystem.js</tt> фактически дает тот же результат, что и передача единичной матрицы в <tt>u_MvpMatrix</tt>, в строке 9 в <tt>CoordinateSystem_viewVolume.js</tt>.
По сути, эта матрица управляет поведением по умолчанию системы WebGL.<br>
Чтобы лучше понять это поведение, давайте посмотрим, что получится, если
в качестве матрицы проекции передать единичную матрицу. Для этого воспользуемся матрицей из приложения C (см. рис. D.6) и найдем в единичной матрице
значения <tt>left</tt>, <tt>right</tt>, <tt>top</tt>, <tt>bottom</tt>, <tt>near</tt> и <tt>far</tt>.
<div class="caption"><img src="img/d_6.png" width=400><br>
Рис. D.6. Матрица проекции, генерируемая методом <tt>setOrtho()</tt></div><br>
В данном случае <tt>right – left = 2</tt> и <tt>right + left = 0</tt>, что дает в результате <tt>left = –1</tt> и <tt>right = 1</tt>.
Аналогично, <tt>far – near = –2</tt> и <tt>far + near = 0</tt>, что дает <tt>near = 1</tt> и <tt>far = –1</tt>.<br>
То есть:
<pre>left = -1, right = 1, bottom = -1, top = 1, near = 1, far = -1</pre>
Передадим эти параметры в вызов <tt>setOrtho()</tt>:
<pre>mvpMatrix.setOrtho(-1, 1, -1, 1, 1, -1);</pre>
Как видите, значение <tt>near</tt> здесь больше значения <tt>far</tt>, а это означает, что дальняя плоскость отсечения находится перед ближней плоскостью отсечения, если смотреть в направлении взгляда (см. рис. D.7).<br>
Подобное явление наблюдается и при определении видимого объема вручную, если задать <tt>near > far</tt>.
То есть, когда видимый объем определяется таким способом, WebGL (OpenGL) следует за соглашением о правосторонней системе координат.<br>
Теперь рассмотрим матрицу, представляющую видимый объем, в котором все объекты отображаются правильно:
<pre>mvpMatrix.setOrtho(-1, 1, -1, 1, -1, 1);</pre>
<div class="caption"><img src="img/d_7.png" width=400><br>
Рис. D.7. Видимый объем, созданный с применением единичной матрицы</div><br>
Этот вызов метода сгенерирует следующую матрицу:
<table align=center style="border-style:solid; border-width:1px; border-color:inherit; border-top-color:transparent; border-bottom-color:transparent; padding-left:0px; padding-right:10px;"><tr><td><pre>
1  0  0  0
0  1  0  0
0  0 −1  0
0  0  0  1</pre></td></tr></table>
В ней без труда можно узнать матрицу масштабирования, описанную в главе 4, «Дополнительные преобразования и простая анимация».
Эта матрица генерируется вызовом <tt>setScale( 1, 1, -1 )</tt>. Обратите внимание на масштабный множитель для оси&nbsp;<tt>Z</tt>, который равен&nbsp;<tt>–1</tt>, это означает изменение направления оси&nbsp;<tt>Z</tt> на обратное.
То есть, эта матрица преобразует привычную для нас правостороннюю систему координат, использующуюся в этой книге (и предполагаемую большинством библиотек для WebGL), в левостороннюю, используемую в усеченной системе координат.<br><br>

<h4>В заключение</h4>
Итак, обратившись к спецификации WebGL, мы выяснили, что система WebGL не связана с какой-то конкретной, лево- или правосторонней системой координат.
Мы узнали, что многие библиотеки и приложения для WebGL следуют за соглашением об использовании правосторонней системы координат.
Когда поведение WebGL по умолчанию противоречит этому соглашению (например, при использовании усеченного пространства,
где используется левосторонняя система координат), эту проблему можно устранить программно, изменив знак, к примеру, координат&nbsp;<tt>Z</tt>.
Это позволит продолжать следовать за соглашением об использовании правосторонней системы координат.
Однако, как отмечалось выше, это всего лишь соглашение, одно из многих, которым следуют люди, но также одно из тех, что может сбивать с толку, если не знать, как действует WebGL по умолчанию и как это исправить.
<br><br>
<h3 id="4">ПРИЛОЖЕНИЕ G.<br>
Мировая и локальная системы координат</h3>
В главе 7, «Вперед, в трехмерный мир», мы впервые попробовали нарисовать трехмерный объект (куб), написав программу, более похожую на «настоящее» приложение трехмерной графики.
Однако в той программе нам потребовалось вручную определить координаты вершин куба и индексы, что оказалось довольно утомительно.
Хотя то же самое мы делали на протяжении всей книги, это не означает, что во всех своих приложениях вам придется вручную вносить все необходимые исходные данные.
Обычно для этого используются специализированные инструменты трехмерного моделирования.
Их применение позволяет создавать сложные трехмерные объекты, манипулируя (объединяя, деформируя, вращая и т. д.) простыми трехмерными фигурами, такими как кубы, цилиндры или сферы.
Один из таких инструментов трехмерного моделирования - <a href="https://www.blender.org/" target="_blank">Blender</a>, показан на рис. G.1.

<h4>Локальная система координат</h4>
При создании трехмерной модели необходимо решить, где будет находиться начало координат (то есть, точка с координатами <tt>(0, 0, 0)</tt>).
Начало координат можно выбрать так, чтобы проще было конструировать модель, или, напротив, так, чтобы ею было проще управлять в трехмерной сцене.
Куб, упоминавшийся в предыдущем разделе, был помещен своим центром в начало координат. Объекты сферической формы, такие как солнце или луна, также обычно создаются так, что их центр совпадает с центром координат.<br><br>
С другой стороны, при моделировании персонажей компьютерных игр, таких как лягушонок, изображенный на рис. G.1, модели обычно конструируются так, что центр координат находится в районе ног, а ось&nbsp;<tt>Y</tt> проходит через центр тела.
Если такого персонажа поместить в координату <tt>Y = 0</tt> (то есть, «поставить» его на поверхность земли), он будет выглядеть, как стоящий на земле – не парящим над ней и не погруженным в землю.
Если перемещать такого персонажа вдоль оси&nbsp;<tt>X</tt> и/или&nbsp;<tt>Z</tt>, у наблюдателя будет создаваться впечатление, что он «ходит» по поверхности.
Кроме того, такого персонажа легко повернуть, реализовав вращение относительно оси <tt>Y</tt>.
<div class="caption"><img src="img/g_1.png" width=500><br>
Рис. G.1. Создание трехмерного объекта с помощью инструмента трехмерного моделирования</div><br>
В таких случаях координаты вершин, составляющих объекты, определяются относительно начала координат. Такая система координат называется локальной.
Используя инструменты моделирования (такие как Blender), компоненты (координаты вершин, цвета, индексы и т. д.) моделей, созданных таким способом,
можно экспортировать в файлы, импортировать их оттуда в объекты буферов и рисовать их с помощью <tt>gl.drawElements()</tt>.

<h4>Мировая система координат</h4>
Теперь рассмотрим в качестве примера компьютерную игру со множеством персонажей, действующих в едином пространстве.
Цель программиста в этом случае состоит в том, чтобы использовать персонажей, изображенных на рис. G.2 справа, в игровом поле, изображенном слева. Все три персонажа и само игровое поле имеют собственные начала координат.
Когда появляется необходимость отобразить персонажи, возникает проблема. Поскольку все персонажи позиционированы относительно начала собственных систем координат, они будут нарисованы в одной точке, поверх друг друга:
<span class="lnk" onmouseover="show('Для наглядности мы немного сместили персонажей относительно друг друга.')" onmouseout="hide()">в точке <tt>(0, 0, 0)</tt> в системе координат трехмерной сцены (рис. G.3)</span>.
Такая ситуация нехарактерна для реального мира и определенно нам не хотелось бы, чтобы она возникала в игре.<br>
<div class="caption"><img src="img/g_2.png" width=700><br>
Рис. G.2. Расположение нескольких персонажей в игровом поле</div><br>
Чтобы исправить эту проблему, нужно изменить местоположение каждого персонажа. Для этого можно воспользоваться преобразованием координат, как рассказывалось в главе 3, «Рисование и преобразование треугольников», и в главе 4,
«Дополнительные преобразования и простая анимация». Например, пингвина можно переместить в позицию <tt>(100, 0, 0)</tt>, мартышку – в позицию <tt>(200, 10, 120)</tt> и собаку – в позицию <tt>(10, 0, 200)</tt>.<br>
<div class="caption"><img src="img/g_3.png" width=500><br>
Рис. G.3. Все персонажи оказались в одной точке</div><br>
Система координат, в которой все персонажи (созданные в локальной системе координат) расставлены по своим местам, называется мировой, или глобальной системой координат.
Соответствующие преобразования моделей называют мировыми преобразованиями.
Разумеется, чтобы исключить возможность размещение персонажей в одной точке, можно было бы сразу создать их в мировой системе координат.
Например, при создании пингвина в программе Blender, можно было бы сразу указать его координаты <tt>(100, 0, 0)</tt>, тогда, при включении в трехмерную сцену,
он сразу оказался бы в точке <tt>(100, 0, 0)</tt> и нам не потребовалось бы выполнять преобразование координат. Однако, такой подход создает свои сложности.
Например, реализовать вращение такого пингвина вокруг своей оси будет намного труднее, потому что вращение относительно оси&nbsp;<tt>Y</tt> пришлось реализовать как движение по окружности с радиусом&nbsp;<tt>100</tt>.
Конечно, можно было бы сначала переместить пингвина в начало координат, повернуть его и затем вернуть на место, но это слишком большой объем работы.<br><br>
В главе 7 мы уже имели дело с подобным случаем. Используя один ряд треугольников, координаты вершин которых были определены относительно общего центра,
программа <tt>PerspectiveView_mvp</tt> рисовала второй ряд треугольников. Ниже показан рисунок, который мы использовали как руководство для создания изображения (см. рис. G.4).
<div class="caption"><img src="img/g_4.png" width=400><br>
Рис. G.4. Группа треугольников, отображаемая программой PerspectiveView_mvp</div><br>
Здесь треугольники, построенные в локальной системе координат, изображены
пунктирными линиями, а для описания их перемещений вдоль оси X используется мировая система координат.

<h4>Преобразования и системы координат</h4>
До сих пор мы не различали локальную и мировую системы координат, чтобы вы могли сосредоточить свое внимание на более важных аспектах примеров.
Однако, для справки, на рис. G.5 показано, как связаны преобразования и системы координат, и эти взаимосвязи нужно запомнить, так как это пригодится вам по мере того,
как вы будете углублять свои познания трехмерной графики и экспериментировать с инструментами трехмерного моделирования.
<div class="caption" id="g5"><img src="img/g_5.png" width=700><br>
Рис. G.5. Преобразования и системы координат</div><br><br><br><br>


<h3 id="5"><a href="https://devburn.ru/2015/07/25/%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82%D1%8B/" target="_blank">И ещё о координатах...</a></h3>На этот раз от <a href="https://github.com/kolosov-sergey" target="_blank">Сергея Колосова</a><br><br>

На этот раз я попробую ответить на Главный Вопрос Жизни, Вселенной и
Всего-всего, а именно — осветить тему координат в WebGL. И начать стоит с
 того, зачем же для представления точки в трехмерном пространстве
используется четыре координаты? И этот вопрос ведет нас к понятию
Однородные координаты...<br><br>

<h4>Часть 1: Однородные координаты</h4>
Итак, в однородных координатах вершины имеют четыре компоненты: <tt>x</tt>, <tt>y</tt>, <tt>z</tt> и <tt>w</tt>, первые три из которых — это привычные всем координаты евклидова пространства. Зачем же нам нужна четвертая компонента?.. Дело в том, что декартовы координаты не позволяют описать смещение (так как за смещение отвечает четвертый столбец матрицы <tt>4х4</tt>).
Кроме того, однородные координаты (в отличие от декартовых) позволяют найти точку пересечения двух параллельных линий — линии пересекутся в бесконечности, что важно для перспективной проекции WebGL.
Для понимания перспективы представьте, что вы стоите между рельсов железной дороги и смотрите вдаль. Несмотря на то, что рельсы параллельны, они будут сужаться по мере удаления, пока не сойдутся в одной точке где-то на горизонте.<br>
Еще одно преимущество однородных координат — они позволяют отличить точку от направления. Если <tt>w = 1</tt>, тогда вектор <tt>(x, y, z, 1)</tt> — это точка в пространстве.
Если <tt>w = 0</tt>, тогда вектор <tt>(x, y, z, 0)</tt> — это направление. Просто запомните это без доказательств.<br>
Перевод декартовых координат в однородные и обратно происходит очень легко. При переводе из декартовых координат в однородные достаточно добавить единицу в четвертую компоненту.
А при переводе из однородных координат в декартовы необходимо все координаты разделить на <tt>w</tt>, после чего отбросить четвертую компоненту.
<ul><li>Декартовы<tt>(x, y, z)</tt> = Однородные<tt>(x, y, z, 1)</tt></li>
<li>Однородные<tt>(x, y, z, w)</tt> = Декартовы<tt>(x/w, y/w, z/w)</tt></li></ul><br>

<h4>Часть 2: Системы координат</h4>
На пути к изображению на мониторе координаты вершин объекта проходят через множество систем координат, включая координаты объекта, мировые координаты, координаты камеры и другие. Рассмотрим их все по порядку.<br><br>

<h5>Координаты объекта</h5>
Здесь еще нет других объектов, сцены и всего другого. Есть только один объект — и все координаты расположены относительно его центра (и Солнце вращается вокруг него, и установлен этот объект на спинах слонов).
Равносторонний куб со стороной равной единице и с центром в координатах <tt>(0, 0)</tt> будет выглядеть следующим образом:<br>
<img src="img/kolosov_ObjectSpace.png" width=600><br>

<h5>Координаты мира</h5>
Когда у нас появляется множество объектов, сразу встает вопрос — как они будут расположены друг относительно друга?
В пространстве объекта у каждого куба была своя система координат, но теперь при отображении всех кубов одновременно нам потребуется новая общая система координат, в роли которой и выступает мировое пространство.
Координаты мира определяют, где расположен тот или иной объект.
На следующей картинке вы можете видеть, как расположены 16 кубов в мировых координатах <tt>(-3, -3, 0)</tt>, <tt>(-3, -1, 0)</tt>, <tt>(-3, 1, 0)</tt> и так далее до <tt>(3, 3, 0)</tt>.<br>
<img src="img/kolosov_WorldSpace.png" width=600><br>
Обратите внимание, как при этом расположена камера.<br>

<h5>Координаты камеры (координаты наблюдателя)</h5>
После того, как все объекты заняли свои места в мировом пространстве, пришло время на них взглянуть. Напомню, что в WebGL нет такого объекта как камера, которым мы могли бы манипулировать.
Предполагается, что камера всегда расположена в координатах <tt>(0, 0, 0)</tt> и направлена в отрицательную сторону оси <tt>Z</tt>.
А раз камеру мы переместить не можем, то нужно переместить объекты таким образом, чтобы они находились перед камерой.
За этот перенос (и поворот с масштабированием) отвечает матрица вида. Но в WebGL нет отдельной матрицы вида (как и матрицы модели, которая должна располагать объект в мировом пространстве).
Вместо этого есть одна матрица модель-вид, совмещающая в себе матрицу модели и матрицу вида.
И вот что мы увидим после умножения на матрицу модель-вид (на самом деле на данном этапе мы еще не можем получить изображение, которое можно вывести на 2D экран, поэтому следующее изображение является довольно условным):<br>
<img src="img/kolosov_Orthographic.png" width=600><br>

<h5>Координаты отсечения</h5>
В сцене может содержаться множество объектов — одни будут позади камеры, другие слева или справа, вне области видимости. Естественно, такие объекты не должны участвовать в рендеринге.
Поэтому цель данного этапа — определить, какой объем пространства попадет на экран и каким образом он будет спроецирован.
Этот объем ограничивается шестью плоскостями (передняя, задняя, левая, правая, верхняя и нижняя) и называется областью видимости камеры (<a href="https://en.wikipedia.org/wiki/Viewing_frustum" target="_blank">frustum</a>):<br>
<img src="img/kolosov_Frustum.png" width=600><br>
Эти шесть плоскостей заложены в проекционной матрице. Вершины, лежащие за пределами области видимости, отсекаются и не участвуют в дальнейшей обработке. Кроме того, форма области видимости задает тип проекции 3D-картинки на 2D-экран.
Если передняя и задняя плоскость будут одинаковых размеров, то будет использована ортографическая проекция (в этом случае объекты вблизи и вдалеке будут иметь одинаковые размеры, что создает не очень реалистичную картину).
В противном случае будет использована перспективная проекция (в этом случае деревья вдалеке будут меньших размеров по сравнению с ближайшими, а рельсы сойдутся на горизонте — именно так мы видим мир в реальной жизни).<br>

<h5>Нормализованные координаты устройства</h5>
На данном этапе область видимости камеры (frustum) проецируется на переднюю плоскость для получения 2D-координат — именно это изображение в дальнейшем станет тем, что мы увидим на мониторе.
Нам уже известно, что для получения декартовых координат необходимо разделить <tt>x</tt>, <tt>y</tt> и <tt>z</tt> на <tt>w</tt> (это еще называется перспективное деление).
После деления мы получаем три компоненты: координаты <tt>x</tt> и <tt>y</tt> определяют положение вершин на плоскости,
а координата <tt>z</tt> отвечает за глубину вершины, что помогает WebGL определить, какие объекты находятся ближе к наблюдателю и попадут на экран, а какие будут перекрыты и не будут отображены.<br>
Нормализованные координаты не зависят от экрана устройства. Вы можете представить их в виде куба, все координаты которого находятся в диапазоне от&nbsp;<tt>-1</tt> до&nbsp;<tt>1</tt> по всем осям.<br>
За перспективное деление также отвечает проекционная матрица.<br>

<h5>Экранные координаты</h5>
Это заключительный этап всех преобразований. Здесь нормализованные координаты устройства выводятся на canvas (который не обязательно должен быть квадратный, в отличие нормализованных координат устройства).
В отличие от предыдущих преобразований здесь не используется матрица. За преобразование в экранные координаты отвечает функция <code>viewport</code>. И вот, что мы увидим на экране:<br>
<img src="img/kolosov_Perspective.png" width=600><br>

<h4>Подводя итоги</h4>
Если обобщить все вышеизложенное, мы получим такую схему:<br>
<img src="img/kolosov_CoordinatesTransformation.png" width=800><br>
Схема также показывает разницу между теорией и реализацией в WebGL — пять трансформаций в теории выполняются за три трансформации в реализации WebGL, каждую из которых мы подробно рассмотрели.<br><br>

<br><br>
</body></html>