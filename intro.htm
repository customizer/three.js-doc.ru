<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Three.js</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>
<body>
<h2 class=head1>Введение</h2>
<h1 id="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Создание сцены</h1>
Цель этого раздела - дать краткое вступление в <em>three.js</em>. Начнем его созданием сюжета с вращающимся кубом. На случай если вы запутаетесь и понадобится помощь, рабочий пример кода <a href="#1.2">приводится ниже</a>.
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Прежде чем начать</h3>
Перед использованием <em>three.js</em>, нужно определиться, где мы будем его показывать. Сохраните следующий HTML-код как файл на своем компьютере вместе с копией файла <tt><a href="http://threejs.org/build/three.js" target="_blank">three.js</a></tt> в папке <tt>js/</tt> и откройте его в своем браузере.
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=utf-8&gt;
    &lt;title&gt;My first Three.js app&lt;/title&gt;
    &lt;style&gt;
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
      &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="js/three.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      // Здесь будет ваш Javascript код.
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
Это все. Весь код ниже идет в пустой тег <tt>&lt;script&gt;</tt>.

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Создание сцены</h3>
Для того, чтобы была возможность что-либо отображать с <em>three.js</em>, нужны три вещи: сцена (scene), камера (camera) и визуализатор (renderer) - также называемый рендерер (по звучанию английского слова), чтобы была возможность показывать сцену, снятую камерой.
<pre>var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );<br>
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );</pre>
Давайте воспользуемся моментом и поясним, что здесь происходит. На данном этапе у нас имеется набор из сцены (переменная <tt>scene</tt>), камеры (переменная <tt>camera</tt>) и визуализатора (переменная <tt>renderer</tt>).
В <em>three.js</em> имеется несколько разных камер. Сейчас мы будем использовать <tt>PerspectiveCamera</tt> (т.е. камеру с отображением перспективы). Первым параметром у нее является
<tt class="lnk" onmouseover="show('сокращение от англ. слов field of view - поле зрения или просмотра - угол,<br>которым ограничена зона видимости камеры, объекты не попадающие<br>'
+'в нее не будут видны.<br>Различают поле зрения по горизонтали и по вертикали.<br>В three.js угол fov - это поле зрения по вертикали и измеряется в градусах.')" onmouseout="hide()">fov</tt> (поле зрения или просмотра).<br><br>
Второй параметр - это <tt class="lnk" onmouseover="show('сокращение от англ. слов<br>aspect ratio - отношение сторон')" onmouseout="hide()">aspect</tt> (соотношение сторон, пропорции или формат кадра).
Почти всегда нужно использовать отношение ширины элемента к его высоте или получите такой же результат как при просмотре старых фильмов на широкоэкранных телевизорах - изображение будет выглядеть сплющенным.<br><br>
Следующими двумя параметрами являются <tt class="lnk" onmouseover="show('от англ. слова near - возле, близко')" onmouseout="hide()">near</tt> (ближняя)
и <tt class="lnk" onmouseover="show('от англ. слова far - далеко')" onmouseout="hide()">far</tt> (дальняя) плоскости отсечения.
Это значит, что объекты дальше, чем значение <b><tt>far</tt></b> или ближе, чем <b><tt>near</tt></b> не будут показаны.
Пока о  них можно не беспокоиться, но для увеличения быстродействия в своем приложении можно использовать другие значения.
<div class=note_trans><b>Примечание переводчика:</b> как говорится "вместо тысячи слов", вот на рисунке показаны все параметры камеры. <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>
<img src="img/1.png" width="600"><br>
Как видите, для камеры задается поле просмотра или поле видимости камеры (параметр <tt>field of view</tt>) в градусах и трехмерное пространство - соотношение ширины и высоты (в параметре <tt>aspect ratio</tt>) и глубина (в параметрах <tt>near</tt> и <tt>far</tt>).</div></div>
Далее идет визуализатор (рендерер). Вот тут то и происходит волшебство.
В дополнение к используемому здесь WebGLRenderer, в <em>three.js</em> имеется несколько других, зачастую используемых в качестве резервного варианта для пользователей со старыми браузерами или тех, у кого нет поддержки WebGL по другим причинам.<br><br>
Помимо создания экземпляра визуализатора (рендерера), также нужно установить размеры в которых будет отображаться наше приложение.
Хорошей идеей будет использование ширины и высоты области, которую нам хочется занять нашим приложением - в данном случае, это ширина и высота элемента <tt>&lt;canvas&gt;</tt>, т.е. полный размер (помните, у <tt>&lt;canvas&gt;</tt> и ширина (<tt>width</tt>) и высота (<tt>height</tt>) равны <tt>100%</tt>) окна браузера.
При выполнении ресурсоёмких приложений также можно задать параметру <tt>setSize</tt> меньшие значения, вроде <tt>window.innerWidth/2</tt> и <tt>window.innerHeight/2</tt>, которые сделают визуализацию приложения в половинном размере.<br><br>
Если нужно сохранить размеры приложения, но отобразить его с более низким разрешением, можно сделать это, вызвав параметр <tt>setSize</tt> со значением <tt>false</tt> в качестве параметра <tt>updateStyle</tt>.<br>
Например, код <tt>setSize(window.innerWidth/2,&nbsp;window.innerHeight/2,&nbsp;false)</tt> сделает визуализацию приложения в половинном разрешении, с учетом того, что наш <tt>&lt;canvas&gt;</tt> имеет <tt>100%</tt>'ую ширину и высоту от размеров окна браузера.<br><br>
И наконец, что не менее важно, к нашему HTML-документу добавляем элемент <b>renderer</b>'а. Это элемент <tt>&lt;canvas&gt;</tt>, на котором рендерер и отображает сцену.<br><br>
<em>Так то все хорошо, но где этот обещанный куб?</em><br>Сейчас мы его добавим.<br><br>
<pre>var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );<br>
camera.position.z = 5;</pre>
Для создания куба нам потребуется <b>BoxGeometry</b>, т.е. геометрия куба.
Это объект, содержащий все точки (вершины - <b>vertices</b> ед. число vertex) и стороны (грани - <b>faces</b>) куба. В дальнейшем мы рассмотрим это более подробно.
<div class=note_trans><b>Примечание переводчика:</b> Здесь и далее слово &#171;геометрия&#187; означает совокупность всех геометрических свойств объекта,
т.е. все элементы, которые составляют каркас объекта - вершины, грани, а также их цвет и расположение. <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>Кроме того, слово грани (в английском варианте это faces, или face в единственном числе) в данной справке имеет двойной смысл: грань - в смысле сторона трехмерной геометрической фигуры и грань - ячейка-треугольник каркаса объекта.<br>
<img src="img/BoxGeometry1.png" width="300"><br>
Получается что грань объекта-куба состоит из треугольных граней ячеек каркаса.<br>
Далее в справке гранью будет называться именно ячейка каркаса, в случае грани, как стороны объекта, будет дополнительное описание, например грань куба.</div></div>
В дополнение к геометрии куба понадобится и материал для его окрашивания. В <em>three.js</em> имеется несколько материалов, но в данном случае будем использовать <tt>MeshBasicMaterial</tt>.
Все материалы принимают свойства объекта, что были к нему применены. Чтобы сохранить простоту вещей, предоставим только атрибут цвета&nbsp;<tt>0x00ff00</tt>, т.е. зеленый цвет. Это работает точно также как в CSS или Photoshop (шестнадцатиричные значения цвета).<br><br>
Третья вещь, что нам потребуется, это <tt>Mesh</tt>, т.е. сетка. <tt>Mesh</tt> представляет собой объект, который принимает геометрию и применяет к ней материал, который потом можно вставить в нашу сцену и свободно перемещаться вокруг.<br><br>
По умолчанию, при вызове <tt>scene.add()</tt>, добавляемая нами вещь будет располагаться в координатах&nbsp;<tt>(0,0,0)</tt>. Чтобы уйти от этого, в последней строке просто немножко смещаем камеру.

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Визуализация (рендеринг) сцены</h3>
Если скопировать код, приведенный выше, и вставить в заранее созданный HTML-файл, то вы ничего не увидите. Потому что на самом деле пока еще нечего отображать. Для того, чтобы что-нибудь появилось нужно то, что называется <tt>render loop</tt> - циклом визуализации.
<pre>function render() {
	requestAnimationFrame( render );
	renderer.render( scene, camera );
}
render();</pre>
Этот код создаст цикл, который будет 60 раз в секунду вызывать визуализатор для прорисовки сцены. Если вы новичок в написании браузерных игр, то можете сказать: "Почему бы нам просто не вызвать JavaScript-функцию <tt class="lnk" onmouseover="show('set interval - установка интервала,<br>т.е. времени между вызовами функции перерисовки сцены')" onmouseout="hide()">setInterval</tt>?"
Конечно же, можно это сделать, но у функции <tt class="lnk" onmouseover="show('request animation frame - запрос кадра анимации<br>- позволяет синхронизировать все анимации со<br>встроенными механизмами обновления страницы.<br><br>То есть, сгруппированы будут не только JavaScript-анимации,<br>но и CSS-анимации и другие браузерные перерисовки. При этом<br>графический ускоритель используется максимально эффективно<br>и исключается повторная обработка одних и тех же участков<br>страницы.<br>А значит – меньше будет загрузка CPU, да и сама анимация<br>станет более плавной.')" onmouseout="hide()">requestAnimationFrame</tt> имеется несколько преимуществ.
Пожалуй, самым важным из них является то, что анимация приостанавливается при переходе пользователя на другую вкладку браузера, а следовательно не тратится драгоценная вычислительная мощность и заряд аккумулятора.<br><br>
<div class=note_trans><b>Примечание переводчика:</b> Вот ещё одна картинка для лучшего понимания процесса визуализации в three.js. <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>
<img src="img/2.png" width="400" align="right"><br>
Это так называемый <span class="lnk" onmouseover="show('Граф — абстрактный математический объект, представляющий из себя<br>множество вершин графа и набор рёбер, то есть соединений между парами вершин.<br>Для разных областей применения виды графов могут различаться направленностью,<br>ограничениями на количество связей и дополнительными данными о вершинах<br>или рёбрах.<br>Многие структуры, представляющие практический интерес в математике<br>и информатике, могут быть представлены графами.')" onmouseout="hide()">граф</span>,
т.е. в нашем случае - совокупность всех объектов, участвующих в визуализации, и связи между ними.<br><br>

Геометрические параметры объекта (т.е. каркас) или попросту "геометрия" - Geometry, составленная из Vertex (вершин) и Face3 (граней-треугольников), передаётся в Mesh (сетку).<br>
Сюда же поступает и Material (материал), который создается после преобразования изображения (Image) в текстуру (Texture).
<br><br>
Грубо говоря, каркас (Geometry) "обтягивается" материалом (Material) при помощи сетки (Mesh). Причем сетка уже является элементом сцены, то есть, её то мы и будем видеть на объекте.<br><br>
Кроме сетки, на сцене находятся освещение и камера. Ну с освещением все понятно, его функция освещать сцену и объекты на ней, а вот с камерой несколько сложнее. Ей задаются параметры, с которыми она должна смотреть на сцену, и передаются в визуализатор или рендерер (renderer). Камеру можно перемещать.<br><br>
Также в рендерер передается и сцена со всеми объектами, находящимися на ней, т.е. вид (или представление, визуализация - render). В этом представлении на сцене, если требуется, можно задать перемещение объектов или всей сцены, т.е. их анимацию.<br><br>
Рендерер показывает нам на &lt;canvas&gt; получившуюся картинку, то есть освещенную сцену с объектами на ней с точки зрения камеры.<br><br>
<span style='float:right; margin-top:-16px; background-color:#ffffe8;'><em>(картинка <a href='http://davidscottlyons.com/threejs/presentations/frontporch14/index.html#slide-16' target='_blank'>отсюда</a>)</em>&nbsp;&nbsp;&nbsp;</span><br></div></div>

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Анимация куба</h3>
Если весь код, приведенный выше, вставлен в заранее созданный файл, вы должны увидеть зеленый куб. Давайте сделаем его чуть поинтереснее - покрутим его.<br>
<img src="img/cube.gif" width="250" align="right"><br>
Добавьте следующий код сразу перед вызовом <b>renderer.render</b> функции <b>render</b>:
<pre>cube.rotation.x += 0.01;
cube.rotation.y += 0.01;</pre>
Этот код будет выполняться в каждом кадре (60 раз в секунду) и задаст кубу хорошую анимацию вращения. В принципе, все что нужно перемещать или изменять во время работы приложения, должно проходить через цикл рендеринга.
Конечно, там можно вызвать и другие функции, но постарайтесь не делать функцию <b>render</b> в несколько сотен строк.

<h3 id="1.2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Итог</h3>
Поздравляем! Вы только что получили свое первое <em>three.js</em> приложение. Как видите, просто нужно было где-то начать.<br><br>
Полный код показан ниже. Чтобы получить более полное представление о его работе,  поиграйтесь с ним (т.е. попробуйте поменять те или иные параметры и понаблюдайте за получающимися изменениями).
<div class="blockindent"><b>Код:</b> <a class='link' onclick='javascript:spoiler1(this)'>... показать</a>
<div style='display:none;'>
<pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My first Three.js app&lt;/title&gt;
    &lt;style&gt;
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="js/three.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );<br>
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );<br>
      var geometry = new THREE.BoxGeometry( 1, 1, 1 );
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      var cube = new THREE.Mesh( geometry, material );
      scene.add( cube );<br>
      camera.position.z = 5;<br>
      var render = function () {
        requestAnimationFrame( render );<br>
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;<br>
        renderer.render(scene, camera);
      };<br>
      render();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><br><br>

<h2 id="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Импорт с помощью модулей</h2>
Несмотря на то, что импорт <em>three.js</em> с помощью тега <tt>&lt;script&gt;</tt> отличный способ быстро получить и начать работать с библиотекой, у него имеется несколько недостатков для продолжительных проектов, например:
<ul><li>Нужно вручную выбирать и подключать копию библиотеки как часть исходного кода проекта.</li>
<li>Обновление версии библиотеки также "ручной" процесс.</li>
<li>При проверке новой версии данной библиотеки управление различия в управлении версиями завалены множеством строк сборочного файла.</li></ul>
Использование диспетчера зависимостей типа <tt>npm</tt> обходит эти условия позволяя просто скачивать и импортировать желаемую версию библиотеки на вашу машину.
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Установка при помощи <tt>npm</tt></h3>
<div class=note_trans><b>Примечание переводчика:</b> npm - сокращ. от Node.js Package Manager — менеджер пакетов, входящий в состав <a href='https://ru.wikipedia.org/wiki/Node.js' target='_blank'>Node.js</a></div>
<em>three.js</em> выпускается как модуль <a href="https://www.npmjs.com/package/three" target="_blank"><tt>npm</tt></a>.
Это значит, что для включения <em>three.js</em> в проект, нужно просто запустить "<tt>npm install three</tt>".
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Импорт модуля</h3>
Предположим, что вы объединяете файлы с помощью такого инструмента как <a href="https://webpack.github.io/" target="_blank">Webpack</a> или <a href="https://github.com/substack/node-browserify" target="_blank">Browserify</a>,
которые позволяют "<tt class=lnk onmouseover="show('require(&quot;modules&quot;) - затребовать модули')" onmouseout="hide()">require('modules')</tt> в браузере, объединив все свои зависимости".
Теперь можно внести модуль в свои исходные файлы и продолжить использовать его в обычном режиме.
<pre>var THREE = require('three');<br>
var scene = new THREE.Scene();
...</pre>
Также есть возможность использования импорта синтаксиса ES6:
<pre>import * as THREE from 'three';<br>
const scene = new THREE.Scene();
...</pre>
или, если хотите импортировать только отдельные части библиотеки <em>three.js</em>, например <tt>Scene</tt>:
<pre>import { Scene } from 'three';<br>
const scene = new Scene();
...</pre>

<h3>Примеры с возможностью импорта</h3>
Основные элементы <em>three.js</em> сфокусированы на наиболее важных компонентах 3D-движка. Множество других компонентов, таких как загрузчики или элементы управления (контролы), являются частью каталога примеров.
<em>three.js</em> обеспечивает синхронизацию этих файлов с основными элементами библиотеки, но если они необходимы для проекта, пользователи должны импортировать их отдельно.
Однако большинство этих файлов не являются модулями, что в некоторых случаях делает их использование неудобным.
Для решения этой проблемы идёт работа над тем, чтобы все примеры были представлены в виде модулей в каталоге <tt>examples/jsm</tt>. Если <em>three.js</em> был установлен через <tt>npm</tt>, можно импортировать их так:
<pre>import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';</pre>
Следующие файлы примеров доступны в виде модулей:
<div style="height:400px; overflow-y:scroll;"><table width=90% align=center>
<tr><td width=33% valign=top>
&#9679; <b>анимация</b>
<div class=list>AnimationClipCreator</div>
<div class=list>CCDIKSolver</div>
<div class=list>MMDAnimationHelper</div>
<div class=list>MMDPhysics</div>
<div class=list>TimelinerController</div>
&#9679; <b>элементы управления (контролы)</b>
<div class=list><a href="https://threejs.org/examples/misc_controls_deviceorientation.html" target="_blank" onmouseover="show('device orientation controls - устройство управления ориентацией')" onmouseout="hide()">DeviceOrientationControls</a></div>
<div class=list><a href="https://threejs.org/examples/#webgl_interactive_draggablecubes" target="_blank" onmouseover="show('drag controls - управление перетаскиванием')" onmouseout="hide()">DragControls</a></div>
<div class=list>EditorControls</div>
<div class=list>FirstPersonControls</div>
<div class=list>FlyControls</div>
<div class=list>MapControls</div>
<div class=list>OrbitControls</div>
<div class=list>OrthographicTrackballControls</div>
<div class=list>PointerLockControls</div>
<div class=list>TrackballControls</div>
<div class=list>TransformControls</div>
&#9679; <b>кривые линии</b>
<div class=list>CurveExtras</div>
<div class=list><a href="https://ru.wikipedia.org/wiki/NURBS" target="_blank" onmouseover="show('NURBS - сокращ. англ. слов non-uniform rational B-spline —<br>неоднородный рациональный B-сплайн, математическая<br>форма, применяемая в компьютерной графике для<br>генерации и представления кривых и поверхностей.')" onmouseout="hide()">NURBSCurve</a></div>
<div class=list>NURBSSurface</div>
<div class=list>NURBSUtils</div>
&#9679; <b>эффекты</b>
<div class=list>AnaglyphEffect</div>
<div class=list>AsciiEffect</div>
<div class=list>OutlineEffect</div>
<div class=list>ParallaxBarrierEffect</div>
<div class=list>PeppersGhostEffect</div>
<div class=list>StereoEffect</div>
&#9679; <b>экспортеры</b>
<div class=list>ColladaExporter</div>
<div class=list>DRACOExporter</div>
<div class=list>GLTFExporter</div>
<div class=list>MMDExporter</div>
<div class=list>OBJExporter</div>
<div class=list>PLYExporter</div>
<div class=list>STLExporter</div>
<div class=list>TypedGeometryExporter</div>
&#9679; <b>загрузчики</b><br>
<div class=list>ctm<br>
CTMLoader</div>
<div class=list>устаревшие<br>
LegacyGLTFLoader<br>
LegacyJSONLoader</div>
<div class=list>3MFLoader</div>
<div class=list>AMFLoader</div>
<div class=list>AWDLoader</div>
<div class=list>AssimpJSONLoader</div>
<div class=list>AssimpLoader</div>
<div class=list>BabylonLoader</div>
<div class=list>BVHLoader</div>
<div class=list>ColladaLoader</div>
<div class=list>DDSLoader</div>
<div class=list>DRACOLoader</div>
<div class=list>EXRLoader</div>
<div class=list>EquirectangularToCubeGenerator</div>
<div class=list>FBXLoader</div>
<div class=list>GCodeLoader</div>
<div class=list>GLTFLoader</div>
<div class=list>HDRCubeTextureLoader</div>
<div class=list>KMZLoader</div>
<div class=list>KTXLoader</div>
<div class=list>LWOLoader</div>
<div class=list>MD2Loader</div>
<div class=list>MMDLoader</div>
<div class=list>MTLLoader</div>
<div class=list>NRRDLoader</div>
<div class=list>OBJLoader</div>
<div class=list>PCDLoader</div>
<div class=list>PDBLoader</div>
<div class=list>PlayCanvasLoader</div>
<div class=list>PLYLoader</div>
<div class=list>PRWMLoader</div>
<div class=list>PVRLoader</div>
<div class=list>RGBELoader</div>
<div class=list>STLLoader</div>
<div class=list>SVGLoader</div>
<div class=list>TDSLoader</div>
<div class=list>TGALoader</div>
<div class=list>TTFLoader</div>
<div class=list>VRMLLoader</div>
<div class=list>VRMLoader</div>
<div class=list>VTKLoader</div>
<div class=list>XLoader</div>
</td>
<td width=33% valign=top>
&#9679; <b>геометрические элементы</b>
<div class=list>BoxLineGeometry</div>
<div class=list>ConvexGeometry</div>
<div class=list>DecalGeometry</div>
<div class=list>ParametricGeometries</div>
<div class=list>TeapotBufferGeometry</div>
&#9679; <b>взаимодействие</b>
<div class=list>SelectionBox</div>
<div class=list>SelectionHelper</div>
&#9679; <b>освещение</b>
<div class=list>LightProbeGenerator</div>
<div class=list>RectAreaLightUniformsLib</div>
&#9679; <b>линии</b>
<div class=list>Line2</div>
<div class=list>LineGeometry</div>
<div class=list>LineMaterial</div>
<div class=list>LineSegments2</div>
<div class=list>LineSegmentsGeometry</div>
<div class=list>Wireframe</div>
<div class=list>WireframeGeometry2</div>
&#9679; <b>элементы математики</b>
<div class=list>ColorConverter</div>
<div class=list>ConvexHull</div>
<div class=list>ImprovedNoise</div>
<div class=list>Lut</div>
<div class=list>SimplexNoise</div>
&#9679; <b>разное</b>
<div class=list>CarControls</div>
<div class=list>ConvexObjectBreaker</div>
<div class=list>GPUComputationRenderer</div>
<div class=list>Gyroscope</div>
<div class=list>MD2Character</div>
<div class=list>MD2CharacterComplex</div>
<div class=list>MorphAnimMesh</div>
<div class=list>MorphBlendMesh</div>
<div class=list>Ocean</div>
<div class=list>RollerCoaster</div>
<div class=list>Volume</div>
<div class=list>VolumeSlice</div>
&#9679; <b>модификаторы</b>
<div class=list>ExplodeModifier</div>
<div class=list>SimplifyModifier</div>
<div class=list>SubdivisionModifier</div>
<div class=list>TessellateModifier</div>
&#9679; <b>объекты</b>
<div class=list>Fire</div>
<div class=list>Lensflare</div>
<div class=list>Reflector</div>
<div class=list>Refractor</div>
<div class=list>ReflectorRTT</div>
<div class=list>ShadowMesh</div>
<div class=list>Sky</div>
<div class=list>Water</div>
<div class=list>Water2</div>
&#9679; <b class="lnk" onmouseover="show('сокращ. от англ. слов Prefiltered Mipmaped Radiance Environment map -<br>карта среды с предварительно отфильтрованной светимостью')" onmouseout="hide()">pmrem</b>
<div class=list>PMREMCubeUVPacker</div>
<div class=list>PMREMGenerator</div>
&#9679; <b>постобработка (постпроцессинг)</b>
<div class=list><a href="https://threejs.org/examples/webgl_shaders_tonemapping.html" target="_blank">AdaptiveToneMappingPass</a></div>
<div class=list>AfterimagePass</div>
<div class=list>BloomPass</div>
<div class=list>BokehPass</div>
<div class=list>ClearPass</div>
<div class=list>CubeTexturePass</div>
<div class=list>DotScreenPass</div>
<div class=list>EffectComposer</div>
<div class=list>FilmPass</div>
<div class=list>GlitchPass</div>
<div class=list>HalftonePass</div>
<div class=list>MaskPass</div>
<div class=list>OutlinePass</div>
<div class=list>RenderPass</div>
<div class=list>SAOPass</div>
<div class=list>SavePass</div>
<div class=list>ShaderPass</div>
<div class=list>SMAAPass</div>
<div class=list>SSAARenderPass</div>
<div class=list>SSAOPass</div>
<div class=list>TAARenderPass</div>
<div class=list>TexturePass</div>
<div class=list><a href="https://threejs.org/examples/webgl_postprocessing_unreal_bloom.html" target="_blank">UnrealBloomPass</a></div>
</td>
<td width=33% valign=top>
&#9679; <b>камеры</b>
<div class=list><a href="https://threejs.org/examples/webgl_camera_cinematic.html" target="_blank" onmouseover="show('cinematic camera - кинематографическая камера')" onmouseout="hide()">CinematicCamera</a></div>
&#9679; <b>визуализаторы (рендереры)</b>
<div class=list>CSS2DRenderer</div>
<div class=list>CSS3DRenderer</div>
<div class=list>Projector</div>
<div class=list>SoftwareRenderer</div>
<div class=list>SVGRenderer</div>
<div class=list>RaytracingRenderer</div>
<div class=list>WebGLDeferredRenderer</div>
&#9679; <b>шейдеры</b>
<div class=list>AfterimageShader</div>
<div class=list>BasicShader</div>
<div class=list>BleachBypassShader</div>
<div class=list>BlendShader</div>
<div class=list>BokehShader</div>
<div class=list>BokehShader2</div>
<div class=list>BrightnessContrastShader</div>
<div class=list>ColorCorrectionShader</div>
<div class=list>ColorifyShader</div>
<div class=list>ConvolutionShader</div>
<div class=list>CopyShader</div>
<div class=list>DepthLimitedBlurShader</div>
<div class=list>DigitalGlitch</div>
<div class=list>DOFMipMapShader</div>
<div class=list>DotScreenShader</div>
<div class=list>FilmShader</div>
<div class=list>FocusShader</div>
<div class=list>FreiChenShader</div>
<div class=list>FresnelShader</div>
<div class=list>FXAAShader</div>
<div class=list>GammaCorrectionShader</div>
<div class=list>GodRaysShader</div>
<div class=list>HalftoneShader</div>
<div class=list>HorizontalBlurShader</div>
<div class=list>HorizontalTiltShiftShader</div>
<div class=list>HueSaturationShader</div>
<div class=list>KaleidoShader</div>
<div class=list>LuminosityHighPassShader</div>
<div class=list>LuminosityShader</div>
<div class=list>MirrorShader</div>
<div class=list>NormalMapShader</div>
<div class=list>OceanShaders</div>
<div class=list>ParallaxShader</div>
<div class=list>PixelShader</div>
<div class=list>RGBShiftShader</div>
<div class=list>SAOShader</div>
<div class=list>SepiaShader</div>
<div class=list>SkinShader</div>
<div class=list>SMAAShader</div>
<div class=list>SobelOperatorShader</div>
<div class=list>SSAOShader</div>
<div class=list>TechnicolorShader</div>
<div class=list>TerrainShader</div>
<div class=list>ToneMapShader</div>
<div class=list>ToonShader</div>
<div class=list>TranslucentShader</div>
<div class=list>TriangleBlurShader</div>
<div class=list>UnpackDepthRGBAShader</div>
<div class=list>VerticalBlurShader</div>
<div class=list>VerticalTiltShiftShader</div>
<div class=list>VignetteShader</div>
<div class=list>VolumeShader</div>
<div class=list>WaterRefractionShader</div>
&#9679; <b>вспомогательные элементы</b>
<div class=list>BufferGeometryUtils</div>
<div class=list>GeometryUtils</div>
<div class=list>MathUtils</div>
<div class=list>SceneUtils</div>
<div class=list><a href="https://threejs.org/examples/webgl_shadowmap_viewer.html" target="_blank">ShadowMapViewer</a></div>
<div class=list>SkeletonUtils</div>
<div class=list>TypedArrayUtils</div>
<div class=list><a href="https://threejs.org/examples/webgl_UVsDebug.html" target="_blank">UVsDebug</a></div>
&#9679; <b>виртуальная реальность</b>
<div class=list>устаревшие<br>
DaydreamController<br>
GearVRController</div>
<div class=list>PaintViveController</div>
<div class=list>ViveController</div>
</td></tr></table></div>
<div class=note><b>Примечание:</b> При использовании кода из каталога примеров важно, чтобы все файлы соответствовали версии основного файла <em>three.js</em>.
Например, нельзя использовать GLTFLoader и OrbitControls версии R96 вместе с <em>three.js</em> версии R103.
Можно запросто синхронизировать файлы с помощью модулей из каталога <tt>jsm</tt>. Если файл недоступен как модуль, все равно можно использовать сторонние <tt>npm</tt>-пакеты или преобразовать файл в модуль самостоятельно.
В обоих случаях следует убедится, что код совместим с вашим основным файлом <em>three.js</em>.</div><br>

<h2 id="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Поддержка браузерами</h2>
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Обзор</h3>
<em>three.js</em> может использовать WebGL для визуализации (рендеринга) сцен во всех современных браузерах.
Для старых браузеров, особенно Internet Explorer 10 и ниже, может потребоваться откат к одному из оставшихся <a href="https://github.com/mrdoob/three.js/tree/master/examples/js/renderers" target="_blank">визуализаторов (рендереров)</a> (CSS2DRenderer, CSS3DRenderer, SVGRenderer, CanvasRenderer).
Кроме того, может потребоваться включение некоторых полифиллов, особенно при использовании файлов из каталога <a href="https://github.com/mrdoob/three.js/tree/master/examples" target="_blank"><tt>/examples</tt></a>.
<div class=note_trans>«Полифилл» (англ. «polyfill» - poly - много, fill - наполнять, заполнять) <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'> — это библиотека, которая добавляет в старые браузеры поддержку возможностей, которые в современных браузерах являются встроенными.
Или, если говорить о современных браузерах, то они тоже не все идут «в ногу», всегда какие-то современные возможности реализуются сначала в одном, потом в другом.
Так вот, первая часть слова говорит о привлечении любого числа технологий, то есть с поставленной задачей можно справиться не только посредством JavaScript, а вторая часть подразумевает заполнение той «дыры» браузера, в которой и должна находиться реализуемая таким образом технология.<br><br>
Полифиллы позволяют исправлять ошибки в конкретном API или добавлять в веб-браузер функционал, который по умолчанию частично или полностью им не поддерживается. Полифиллы не создают лишних зависимостей и могут быть легко удалены, когда они больше не нужны.<br>
Обычно полифилл состоит из двух частей:
<div class=blockindent>Проверка, есть ли встроенная возможность.<br>Эмуляция, если её нет.</div>
По мнению <span class="lnk" onmouseover="show('Термин был придуман Реми Шарпом (англ. Remy Sharp) в 2009 году<br>во время работы над книгой «Введение в HTML5»')" onmouseout="hide()">автора термина</span>,
ассоциация с заделыванием трещин и дыр в стенах вполне подходит для визуализации того, как полифиллы в веб-программировании «ремонтируют» браузер.</div></div>
<div class=note><b>Примечание:</b> если поддержка устаревших браузеров не требуется, то не рекомендуется использовать другие визуализаторы-рендереры, отличные от WebGLRenderer, так как они работают медленнее и поддерживают меньшее количество функций.</div>

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Браузеры, поддерживающие WebGL</h3>
WebGL поддерживается следующими браузерами: Google Chrome 9+, Firefox 4+, Opera 15+, Safari 5.1+, Internet Explorer 11 и Microsoft Edge.
Узнать, какие браузеры поддерживают WebGL можно на <a href="https://caniuse.com/#feat=webgl" target="_blank" onmouseover="show('название сайта переводится как<br>&#171;могу ли я пользоваться WebGL&#187;');" onmouseout="hide()">Can I use WebGL</a>.

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Используемые в three.js функции на языке JavaScript или Web API</h3>
Вот несколько функций, используемых в <em>three.js</em>. Для некоторых из них может потребоваться дополнение полифиллами.
<table class="tbl_1" border="1" cellpadding="5" width="90%">
<tr class="head"><td>функции<br>Feature</td><td>область&nbsp;применения<br>Use Scope</td><td>модули<br>Modules</td></tr>
<tr valign="top"><td>Typed Arrays </td><td>Исходник</td><td>BufferAttribute, BufferGeometry и т.д.</td></tr>
<tr valign="top"><td>Web Audio API</td><td>Исходник</td><td>Audio, AudioContext, AudioListener и т.д.</td></tr>
<tr valign="top"><td>WebVR API</td><td>Исходник</td><td>WebVRManager и т.д.</td></tr>
<tr valign="top"><td>Blob</td><td>Исходник</td><td>FileLoader, etc.</td></tr>
<tr valign="top"><td>Promise</td><td>Примеры</td><td>GLTFLoader, GLTF2Loader, WebVR, VREffect и т.д.</td></tr>
<tr valign="top"><td>Fetch</td><td>Примеры</td><td>ImageBitmapLoader и т.д.</td></tr>
<tr valign="top"><td>File API</td><td>Примеры</td><td>GLTFExporter и т.д.</td></tr>
<tr valign="top"><td>URL API</td><td>Примеры</td><td>GLTFLoader и т.д.</td></tr>
<tr valign="top"><td>Pointer Lock API </td><td>Примеры</td><td>PointerLockControls</td></tr></table><br>

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Полифиллы</h3>
Просто импортируйте полифиллы, исходя из своих требований. Если в качестве примера взять IE9, то потребуются полифиллы как минимум к этим функциям:
<ul><li>Typed Arrays</li>
<li>Blob</li></ul>
Рекомендуемые полифиллы
<ul><li><a href="https://github.com/zloirock/core-js" target="_blank">core-js</a></li>
<li><a href="https://github.com/inexorabletash/polyfill/blob/master/typedarray.js" target="_blank">typedarray.js</a></li>
<li><a href="https://github.com/stefanpenner/es6-promise/" target="_blank">ES6-Promise</a></li>
<li><a href="https://github.com/eligrey/Blob.js" target="_blank">Blob.js</a></li>
<li><a href="https://github.com/github/fetch" target="_blank">fetch</a></li></ul><br><br>



<h2 id="4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Обнаружение совместимости браузера с WebGL</h2>
Несмотря на то, что проблема встречается все реже и реже, некоторые устройства или браузеры все ещё не могут работать с WebGL.<br>
Описанный ниже метод проверяет, поддерживается ли WebGL и, если это не так, выводит сообщение пользователю.<br><br>
Добавьте с своему javascript-коду <a href="https://github.com/mrdoob/three.js/blob/master/examples/js/WebGL.js" target="_blank">эту функцию</a> и прежде чем пытаться что-либо отобразить, запускайте следующий код.
<pre>if ( WEBGL.isWebGLAvailable() ) {
  // Initiate function or other initializations here
  // Здесь располагается инициализация функции или другие инициализации
    animate();
} else {
	var warning = WEBGL.getWebGLErrorMessage();
	document.getElementById( 'container' ).appendChild( warning );
}</pre><br><br>

<h2 id="5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Как все это запустить локально</h2>
Если используются только конструкции, предусмотренные в <em>three.js</em>, и никаких текстур дополнительно не загружается, веб-страницы должны работать прямо из файловой системы, просто сделайте двойной клик в файловом менеджере по HTML файлу и он должен появиться и начать работать в браузере (в адресной строке будет видно <tt>file:///yourFile.html</tt>).

<h3>Содержимое, загружаемое из внешних файлов</h3>
Если модели или текстуры загружаются из внешних файлов, из-за ограничений безопасности по
<span class="lnk" onmouseover="show('Правило ограничения домена (Same Origin Policy, в переводе<br>с англ. «Принцип одинакового источника») — это важная<br>концепция безопасности для некоторых языков программирования<br>на стороне клиента, таких как JavaScript.<br>'
+'Политика разрешает сценариям, находящимся на страницах<br>одного сайта, доступ к методам и свойствам друг друга без<br>ограничений, но предотвращает доступ к большинству методов<br>и свойств для страниц на разных сайтах.<br>'
+'Одинаковые источники — это источники, у которых совпадают<br>три признака: домен, порт, протокол.')" onmouseout="hide()">правилу ограничения домена</span>
браузера, загрузка из файловой системы завершится ошибкой и выдачей сообщения с описанием исключения безопасности.
<div class=note_trans><b>Примечание переводчика:</b> Вот ссылки на статьи в Википедии про <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B0" target="_blank">Правило ограничения домена</a> и <a href="http://en.wikipedia.org/wiki/Same_origin_policy" target="_blank">Same Origin Policy</a>.</div>
Существует два способа решения этой проблемы:
<ol><li>Изменить для локальных файлов правила безопасности в браузере. Это позволит получить доступ к своей странице как: <tt>file:///yourFile.html</tt></li>
<li>Запускать файлы из локального веб-сервера. Это позволит получить доступ к своей странице как: <tt>http://localhost/yourFile.html</tt></li></ol>
При использовании первого варианта имейте в виду, что если используете тот же самый браузер и для обычного веб-серфинга, можно открыть некоторые уязвимости.
Для безопасности, можно создать отдельный профиль/ярлык браузера только для локального применения. Давайте рассмотрим каждый вариант по очереди.<br><br>

<h3>Изменение политики безопасности локальных файлов в браузере</h3>
<h4>Safari</h4>
<div class="blockindent">С помощью панели настройки включите меню разработки, через Advanced (дополнительно) <tt>=&#62;</tt> "Show develop menu in menu bar" (показывать меню разработки в панели меню).<br><br>
Затем в меню "Develop" (разработка) браузера выберите "Disable local file restrictions" (отключить ограничения локальных файлов), стоит также отметить, что Safari имеет несколько странное поведение при работе с кэшем,
так что в том же меню желательно использовать опцию "Disable caches" (отключить кэш); если редактирование и отладка ведуться с помощью Safari.</div>

<h4>Chrome</h4>
<div class="blockindent">Вначале закройте все работающие экземпляры браузера Chrome. Главное слово здесь "все".<br><br>
В операционной системе Windows можно проверить число используемых экземпляров Chrome через Панель задач. Кроме того, если в системном трее видно иконку Chrome, можно открыть его контекстное меню и кликнуть 'Exit' - выйти. Это должно закрыть все экземпляры браузера Chrome.<br><br>
Затем запустите исполняемый файл Chrome с флагом командной строки:
<pre>chrome --allow-file-access-from-files</pre>
В ОС Windows, возможно, самым простым способом является создание специального ярлыка, в котором добавлен флаг, указанный выше
(правый клик по иконке ярлыка вызовет контекстное меню, в котором нужно сделать левый клик на строке Свойства (Properties). В открывшемся окне свойств ярлыка, в строке Объект (Target) и нужно добавить упомянутый флаг).<br><br>
В операционной системе Mac OSX это делается с помощью
<pre>open /Applications/Google\ Chrome.app --args --allow-file-access-from-files</pre></div>

<h4>Firefox</h4>
<ol><li>Наберите в адресной строке <tt>about:config</tt></li>
<li>Найдите параметр <tt>security.fileuri.strict_origin_policy</tt></li>
<li>Установите его как <em>false</em></li></ol><br><br>

<h3>Запуск локального сервера</h3>
На многих языках программирования имеются встроенные простые HTTP-серверы.
Они не настолько полнофункциональны, как реально работающие сервера, подобные <a href="https://www.apache.org/" target="_blank">Apache</a> или <a href="https://nginx.org" target="_blank">NGINX</a>, тем не менее они должны быть достаточны для тестирования приложения three.js.<br>
<div>
<h4>Запуск сервера Python</h4>
<div class="blockindent">Если установлен <a href="http://python.org/" target="_blank">Python</a>, то его должно быть достаточно для запуска сервера из командной строки (из рабочего каталога):
<pre>//Python 2.x
python -m SimpleHTTPServer<br>
//Python 3.x
python -m http.server</pre>
Он будет обслуживать файлы из текущего каталога в localhost по 8000 порту, то есть, в адресной строке наберите:
<pre>http://localhost:8000/</pre></div><br>

<h4>Запуск сервера Ruby</h4>
<div class="blockindent">Если установлен Ruby, можно получить тот же результат, запустив взамен следующее:
<pre>ruby -r webrick -e "s = WEBrick::HTTPServer.new(:Port => 8000, :DocumentRoot => Dir.pwd); trap('INT') { s.shutdown }; s.start"</pre></div><br>

<h4>Запуск сервера PHP</h4>
<div class="blockindent">В PHP также имеется встроенный сервер, начиная с версии php 5.4.0:
<pre>php -S localhost:8000</pre></div><br>

<h4>Запуск сервера Node.js</h4>
<div class="blockindent">В Node.js имеется простой пакет HTTP сервера. Для установки:
<pre>npm install http-server -g</pre>
Для запуска (из локального каталога):
<pre>http-server . -p 8000</pre></div><br>

<h4>Запуск сервера lighttpd на Mac</h4>
<div class="blockindent">Lighttpd - это очень легковесный веб-сервер общего назначения. Сейчас расскажем о его установке на OSX с помощью HomeBrew.
В отличие от других серверов, обсуждаемых здесь, lighttpd - это полноценный сервер, готовый к реальной работе.
<ol><li>Устанавливаем сервер через homebrew
<pre>brew install lighttpd</pre></li>
<li>В каталоге, где нужно запустить веб-сервер, создаем файл настройки с названием lighttpd.conf. <a href="http://redmine.lighttpd.net/projects/lighttpd/wiki/TutorialConfiguration" target="_blank">Вот здесь</a> имеется пример.</li>
<li>В файле настройки заменяем значение параметра server.document-root на каталог, в котором нужно обслуживать файлы.</li>
<li>Запускаем его
<pre>lighttpd -f lighttpd.conf</pre></li>
<li>Переходим на http://localhost:3000/ и он будет обслуживать статические файлы из выбранного каталога.</li></ol></div><br>
Другие простейшие варианты обсуждаются например на <a href="http://stackoverflow.com/q/12905426/24874" target="_blank">Stack Overflow</a>.</div><br><br>

<h2 id="5a">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Как использовать WebGL2</h2>
Начиная с версии <tt>R95</tt>, движок <em>three.js</em> поддерживает визуализацию (рендеринг) с помощью WebGL 2. По умолчанию, при создании экземпляра WebGLRenderer всегда используется контекст WebGL 1.
Если требуется использовать контекст WebGL 2, ознакомьтесь со следующей последовательностью действий.<br><br>

<h4>Последовательность выполняемых действий</h4>
Поскольку WebGL 2 поддерживается не всеми устройствами, поддерживающими WebGL 1, важно проверить соответствующую возможность. Для этого необходимо включить в проект <a href="https://github.com/mrdoob/three.js/blob/master/examples/js/WebGL.js" target="_blank">WebGL.js</a>.
<pre>&lt;script src="/path/to/WebGL.js"&gt;&lt;/script&gt;</pre>
Затем, для выполнения проверки на доступность WebGL 2, используйте следующий код:
<pre>if ( WEBGL.isWebGL2Available() === false ) {
  document.body.appendChild( WEBGL.getWebGL2ErrorMessage() );
}</pre>
Теперь пришло время создать визуализатор (рендерер), применяя элемент HTML5 <tt>canvas</tt> и соответствующий контекст WebGL 2 в конструкторе WebGLRenderer.
В итоге, <em>three.js</em> внутри себя будет использовать для визуализации данный контекст и автоматически сконвертирует шейдерный код встраиваемого материала в код GLSL&nbsp;ES&nbsp;3.00.
<pre>var canvas = document.createElement( 'canvas' );
var context = canvas.getContext( 'webgl2' );
var renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );</pre>
Иногда требуется написать собственный код шейдера. В качестве основы для своей собственной реализации используйте следующий шаблон кода. Во-первых, код GLSL&nbsp;ES&nbsp;3.00.
<pre>&lt;script id="vs" type="x-shader/x-vertex">
#version 300 es<br>
void main() {
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
&lt;/script>
&lt;script id="fs" type="x-shader/x-fragment">
#version 300 es<br>
precision highp float;
precision highp int;
out vec4 out_FragColor;<br>
void main() {
  out_FragColor = vec4( 1.0 );
}
&lt;/script></pre>
А во-вторых, код создания соответствующего материала на JavaScript.
<pre>var material = new THREE.ShaderMaterial( {
	vertexShader: document.getElementById( 'vs' ).textContent.trim(),
	fragmentShader: document.getElementById( 'fs' ).textContent.trim()
} );</pre><br>

<h4>Дальнейшие действия</h4>
Посмотрите на один из официальных примеров, чтобы увидеть в действии функции WebGL 2.
<pre><a href="https://threejs.org/examples/#webgl2_materials_texture3d" target="_blank">WebGL2 / materials / texture3d</a>
<a href="https://threejs.org/examples/#webgl2_materials_texture3d_volume" target="_blank">WebGL2 / materials / texture3d / volume</a>
<a href="https://threejs.org/examples/#webgl2_multisampled_renderbuffers" target="_blank">WebGL2 / multisampled renderbuffers</a></pre><br>

<h4>Поддерживаемые функции</h4>
В настоящий момент движок поддерживает только часть всех существующих функций WebGL 2. В списке ниже представлен обзор того, что уже доступно в последней версии <em>three.js</em>.
<ul><li>3D Textures (трехмерные текстуры)</li>
<li>Multisampled Renderbuffers (буфер визуализации с возможностью мультивыборки)</li></ul>
<br><br>

<h2 id="6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Рисование линий</h2>
Предположим, нужно нарисовать линию или круг, без каркасной <a href="objects.htm#8" onmouseover="show('Mesh')" onmouseout="hide()">сетки</a>.
Вначале нужно установить <a href="renderers.htm" onmouseover="show('WebGLRenderer')" onmouseout="hide()">рендерер (визуализатор)</a>, <a href="scenes.htm#3">сцену</a> и камеру (смотрите страницу <a href="#1">Создание сцены</a>).<br><br>
Вот код, который для этого будет использоваться:
<pre>var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);<br>
var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
camera.position.set(0, 0, 100);
camera.lookAt(new THREE.Vector3(0, 0, 0));<br>
var scene = new THREE.Scene();</pre>
Следующее, что нужно сделать, это определить материал. Для линий можно использовать <a href="materials.htm#1">LineBasicMaterial</a> или <a href="materials.htm#2">LineDashedMaterial</a>.
<pre>//create a blue LineBasicMaterial (создадим синий LineBasicMaterial)
var material = new THREE.LineBasicMaterial({ color: 0x0000ff });</pre>
После определения материала нужно определиться с <a href="core.htm#7">Geometry</a> или <a href="core.htm#2">BufferGeometry</a> с некоторым количеством вершин
(рекомендуется использовать BufferGeometry как более производительную, однако для упрощения здесь будет использована Geometry):
<pre>var geometry = new THREE.Geometry();
geometry.vertices.push(new THREE.Vector3(-10, 0, 0));
geometry.vertices.push(new THREE.Vector3(0, 10, 0));
geometry.vertices.push(new THREE.Vector3(10, 0, 0));</pre>
Обратите внимание, что линии проведены между каждой последующей парой вершин, но не между первой и последней (то есть, эта линия не замкнута).<br><br>
Теперь, когда есть точки для двух линий и материал, можно сложить все вместе для формирования линии.
<pre>var line = new THREE.Line(geometry, material);</pre>
Все что осталось, вывести (добавить) её на сцену и вызвать <a href="renderers.htm#method_render" onmouseover="show('WebGLRenderer.render')" onmouseout="hide()">рендерер</a>.
<pre>scene.add(line);
renderer.render(scene, camera);</pre>
Теперь вы должны увидеть стрелку из двух синих линий, направленную вверх.<br><br>

<h2 id="7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Создание текста</h2>
Часто бывает так, что в приложении <em>three.js</em> нужно использовать текст - вот несколько способов, как можно это сделать.

<h3>1. DOM + CSS</h3>
Использование HTML - это наиболее простой и быстрый способ добавления текста. Этот метод используется для прилагаемых изображений к большинству примеров <em>three.js</em>.<br><br>
Можно добавить содержимое в
<pre>&lt;div id="info"&gt;Description&lt;/div&gt;</pre>
и использовать CSS-разметку для размещения в абсолютно независимой позиции и поверх всего остального по z-индексу, особенно если приложение <em>three.js</em> работает в полноэкранном режиме.
<pre>#info {
	position: absolute;
	top: 10px;
	width: 100%;
	text-align: center;
	z-index: 100;
	display:block;
}</pre>

<h3>2. Нарисовать текст на canvas и использовать его как <a href="textures.htm#6" onmouseover="show('Texture')" onmouseout="hide()">текстуру</a></h3>
Используйте этот способ, если хочется просто нарисовать текст на плоскости, на своей <em>three.js</em>-сцене.

<h3>3. Создать модель текста в выбранной вами программе 3D-графики<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;и экспортировать её в <em>three.js</em></h3>
Используйте этот способ, если предпочитаете работать со своей программой 3D-графики и вставьте эту модель в <em>three.js</em>.

<h3>4. Геометрические элементы <span class="lnk" onmouseover="show('процедурный текст - расписанная последовательность действий,<br>помогающая решить определенную задачу. Например: рецепт,<br>правила игры, инструкция по эксплуатации и т.д.')" onmouseout="hide()">процедурного текста</span></h3>
Если предпочитаете работать исключительно в <em>three.js</em> или создавать процедурные и динамичные трехмерные (3D) текстовые геометрические элементы,
можно создать сетку, геометрические элементы которой являются экземпляром THREE.TextGeometry:
<pre>new THREE.TextGeometry( text, parameters );</pre>
Для того, чтобы это сработало, для TextGeometry будет нужен экземпляр THREE.Font, установленный в качестве значения его параметра "<tt>font</tt>" - шрифт.
Посмотрите страницу <a href="geometries.htm#34" onmouseover="show('TextGeometry')" onmouseout="hide()">TextGeometry</a> для получения дополнительных сведений о том, как это можно сделать с описанием каждого принимаемого параметра и списком
<a href="https://ru.wikipedia.org/wiki/JSON" target="_blank" onmouseover="show('сокращение от англ. слов JavaScript Object Notation<br>(обычно произносится как джейсэн) — текстовый формат<br>обмена данными, основанный на JavaScript.<br>Как и многие другие текстовые форматы, JSON легко<br>читается людьми. Формат JSON был разработан<br>Дугласом Крокфордом.')" onmouseout="hide()">JSON</a>-шрифтов, поставляемых в составе самого <em>three.js</em>.

<h4>Примеры</h4>
<a href="https://threejs.org/examples/#webgl_geometry_text" target="_blank"> WebGL / geometry / text</a><br>
<a href="https://threejs.org/examples/#canvas_geometry_text" target="_blank">canvas / geometry / text</a><br>
<a href="https://threejs.org/examples/#webgl_shadowmap" target="_blank"> WebGL / shadowmap</a><br><br>
Если шрифт не работает или нужно использовать шрифт, которого здесь нет, существует <a href="http://www.jaanga.com/2012/03/blender-to-threejs-create-3d-text-with.html" target="_blank">руководство со скриптом на языке Python</a> для
<a href="https://www.blender.org/" target="_blank" onmouseover="show('свободный, профессиональный пакет для создания<br>трёхмерной компьютерной графики, включающий в себя<br>средства моделирования, анимации, рендеринга,<br>постобработки и монтажа видео со звуком')" onmouseout="hide()">Blender'а</a>, который позволяет экспортировать текст в понятном для <em>three.js</em> формате JSON.

<h3>5. Растровые шрифты (bitmap fonts)</h3>
Растровые шрифты (bitmap fonts - BMFonts) позволяют группировать символы шрифта (глифы) в отдельный <a href="core.htm#2" onmouseover="show('BufferGeometry')" onmouseout="hide()">BufferGeometry</a>.
Визуализация растрового шрифта поддерживает перенос слов, межбуквенный интервал, <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B5%D1%80%D0%BD%D0%B8%D0%BD%D0%B3" target="_blank" onmouseover="show('Кернинг — это уменьшение или увеличение расстояния<br>между буквами, из которых складывается слово.')" onmouseout="hide()">кернинг</a>,
<span class="lnk" onmouseover="show('<img src=\'img/sdf.png\'><br>поля расстояний со знаком (signed distance fields, SDF) —<br>это изображение из оттенков серого, сгенерированное из<br>контрастного черно-белого изображения, в котором уровень<br>серого цвета означает дистанцию до ближайшей<br>контрастной границы.')" onmouseout="hide()">поля расстояний со знаком и стандартными производными</span>,
многоканальные поля расстояний со знаком, многотекстурные шрифты и многое другое.
Смотрите <a href="https://github.com/Jam3/three-bmfont-text" target="_blank">three-bmfont-text</a>.
<div class=note_trans><b>Примечание переводчика:</b> Более подробно с полями расстояний со знаком можно ознакомится в статьях <a href="https://habr.com/ru/post/438316/" target="_blank">Основы Signed Distance Field в 2D</a> и <a href="https://habr.com/ru/post/282191/" target="_blank">Рендеринг UTF-8 текста с помощью SDF шрифта</a></div>
Стандартные шрифты доступны в таких проектах, как <a href="https://github.com/etiennepinchon/aframe-fonts" target="_blank">A-Frame Fonts</a>,
или можно создать свой собственный шрифт из любого шрифта в формате <tt>.TTF</tt>, оптимизировав его включением только тех символов, которые необходимы для проекта.

<h4>Некоторые полезные инструменты:</h4>
<a href="http://msdf-bmfont.donmccurdy.com/" target="_blank">msdf-bmfont-web</a> (доступ через интернет)<br>
<a href="https://github.com/soimy/msdf-bmfont-xml" target="_blank">msdf-bmfont-xml</a> (командная строка)<br>
<a href="https://github.com/libgdx/libgdx/wiki/Hiero" target="_blank">hiero</a> (приложение для настольного компьютера)<br><br>


<h2 id="8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Загрузка трехмерных моделей</h2>
3D-модели доступны в сотнях форматов файлов, каждый из которых имеет разное назначение, разнообразные функции и различную сложность.
Хотя <em>three.js</em> <a href="https://github.com/mrdoob/three.js/tree/dev/examples/js/loaders" target="_blank">предоставляет множество загрузчиков</a>, выбор правильного формата и рабочего процесса позволит сохранить время и избежать разочарования в дальнейшем.
С некоторыми форматами сложно работать из-за неэффективной работы в реальном времени или  из-за того, что нет полной поддержки в настоящее время.<br>
Данное руководство предоставляет рекомендуемый рабочий процесс, подходящий большинству пользователей, и предложения о том, что нужно делать, если все идет не так, как ожидалось.<br><br>

<h3>Прежде чем начать</h3>
Если вы плохо знакомы с управлением локального сервера, для начала ознакомьтесь со статьей <a href="#5">&#171;Как все это запустить локально&#187;</a>. Большинство распространенных ошибок, связанных с просмотром 3D-моделей, можно избежать правильным размещением файлов.<br><br>

<h3>Рекомендуемый рабочий процесс</h3>
Там, где это возможно, рекомендуется использовать формат glTF (GL Transmission Format).
Поддерживаются оба варианта формата и GLB, и GLTF. Поскольку этот формат ориентирован на доставку ресурса во время выполнения кода, он компактен для передачи и быстр для загрузки.
Возможности формата включают в себя сетки (mesh), материалы, текстуры, скины (skin), скелеты (skeleton), цели морфинга (morph target), анимации, виды освещения и камеры.<br>
Общедоступные glTF-файлы имеются на таких сайтах, как <a href="https://sketchfab.com/models?features=downloadable&sort_by=-likeCount&type=models" target="_blank">Sketchfab</a>, или в различных инструментах включен экспорт glTF:
<ul><li><a href="https://github.com/KhronosGroup/glTF-Blender-Exporter" target="_blank">glTF-Blender-Exporter</a> от Khronos Group</li>
<li><a href="https://github.com/KhronosGroup/COLLADA2GLTF" target="_blank">COLLADA2GLTF</a> от Khronos Group</li>
<li><a href="https://github.com/facebookincubator/FBX2glTF" target="_blank">FBX2GLTF</a> от Facebook</li>
<li><a href="https://github.com/AnalyticalGraphicsInc/obj2gltf" target="_blank">OBJ2GLTF</a> от Analytical Graphics Inc</li>
<li><a href="https://www.allegorithmic.com/products/substance-painter" target="_blank">Substance Painter</a> от Allegorithmic</li>
<li><a href="https://www.foundry.com/products/modo" target="_blank">Modo</a> от Foundry</li>
<li><a href="https://www.marmoset.co/toolbag/" target="_blank">Toolbag</a> от Marmoset</li>
<li><a href="https://www.sidefx.com/products/houdini/" target="_blank">Houdini</a> от SideFX</li>
<li><a href="https://labs.maxon.net/?p=3360" target="_blank">Cinema 4D</a> от MAXON</li>
<li>и <a href="https://github.com/khronosgroup/gltf#gltf-tools" target="_blank">многое другое</a> ...</li></ul>
Если все же предпочитаемые инструменты не поддерживают glTF, можно запросить экспорт glTF у авторов или разместить сообщение о нем в <a href="https://github.com/KhronosGroup/glTF/issues/1051" target="_blank">ветке дорожной карты glTF</a>.<br>
Когда glTF - это не вариант, то доступны и правильно поддерживаются такие популярные форматы, как FBX, OBJ или COLLADA.<br><br>

<h3>Загрузка</h3>
Только несколько загрузчиков (например, <a href="loaders.htm#16" onmouseover="show('ObjectLoader')" onmouseout="hide()">ObjectLoader</a>) включены в <em>three.js</em> по умолчанию - остальные должны добавляться на страницу отдельно.
В зависимости от предпочтений и удобства пользования инструментами сборки, выберите один из следующих вариантов:
<pre>// global script (глобальный скрипт)
&#60;script src="GLTFLoader.js"&#62;&#60;/script&#62;<br>
// commonjs (обычный js-код )
var THREE = window.THREE = require('three');
require('three/examples/js/loaders/GLTFLoader');</pre>
В настоящее время примеры <em>three.js</em> недоступны в качестве модулей ES (<tt>import ... from '...'</tt>). Несколько обходных путей обсуждаются в <a href="https://github.com/mrdoob/three.js/issues/9562" target="_blank">#9562</a>.<br>
После импорта загрузчика, можно добавить модель на сцену. Для разных загрузчиков синтаксис различается - при работе с другим форматом проверьте документацию и примеры использования для загрузчика этого формата.
Для glTF основным примером использования будет:
<pre>var loader = new THREE.GLTFLoader();
loader.load( 'path/to/model.glb', function ( gltf ) {
  scene.add( gltf.scene );
}, undefined, function ( error ) {
  console.error( error );
} );</pre>
Чтобы узнать подробнее, посмотрите <a href="examples.htm#3.2" onmouseover="show('GLTFLoader')" onmouseout="hide()">документацию GLTFLoader</a>.<br><br>

<h3>Поиск и устранение неисправностей</h3>
Затратив часы на моделирование своего рукотворного шедевра, запускаете его загрузку на веб-страницу и бац, - не работает! Он искажен, обесцвечен или вообще отсутствует. Начните поиск и устранение неисправностей со следующих шагов:
<ol><li>Проверьте консоль JavaScript на ошибки и убедитесь, что используется функция обратного вызова на событие <tt class=lnk onmouseover="show('on error - на ошибку')" onmouseout="hide()">onError</tt>
при вызове метода <tt class=lnk onmouseover="show('load - загрузка')" onmouseout="hide()">load</tt> для записи результата.</li>
<li>Посмотрите модель в другом приложении. Для glTF, программы просмотра с перетаскиванием доступны на <a href="https://gltf-viewer.donmccurdy.com/" target="_blank">three.js</a> и <a href="http://sandbox.babylonjs.com/" target="_blank">babylon.js</a>.
Если модель отображается правильно в одном или нескольких приложениях, <a href="https://github.com/mrdoob/three.js/issues/new" target="_blank">отправьте сообщение об ошибке в файле <em>three.js</em></a>.
Если модель не отображается ни в одном из приложений, настоятельно рекомендуется увязать ошибку с приложением, используемом для создания данной модели.</li>
<li>Попробуйте масштабировать модель, уменьшив или увеличив её в 1000 раз. Множество моделей масштабируются по-разному, и крупные модели могут не отображаться, если камера окажется внутри модели.</li>
<li>Присмотритесь нет ли неудачных запросов текстуры в сетевых закладках, вроде <tt>C:\\Path\To\Model\texture.jpg</tt>.
Вместо них используйте пути относительно своей модели, такие как <tt>images/texture.jpg</tt> - при этом может понадобиться изменение файла модели в текстовом редакторе.</li></ol>

<h3>Обратитесь за помощью</h3>
Если процесс поиска неисправностей, указанный выше, пройден, а модель так и не работает, правильно будет обратиться за помощью, что ускорит решение проблемы.
Задайте вопрос на <a href="https://discourse.threejs.org/" target="_blank">форуме <em>three.js</em></a> и, если возможно,
включите свою модель (или какую-либо наиболее простую модель с той же самой проблемой) в любом доступном формате.
Включите достаточно сведений для того, чтобы кто-то другой быстро воспроизвел проблему - в идеале, демонстрационный пример &#171;вживую&#187;.<br><br>


<h2 id="9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Руководство по миграции и стилю кода</h2>
Руководство <span class="lnk" onmouseover="show('то есть, по переводу программ three.js, сделанных<br>в одной версии, для работы в другой версии three.js')" onmouseout="hide()">по миграции</span> хранится на <a href="https://github.com/mrdoob/three.js/wiki" target="_blank">wiki</a>.
Оно содержит список изменений каждой версии three.js, начиная с релиза r45.<br>
Его можно найти <a href="https://github.com/mrdoob/three.js/wiki/Migration-Guide" target="_blank">здесь</a>.<br>
<div class=note_trans><b>Примечание переводчика:</b> Вики (англ. wiki) — веб-сайт, <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>содержимое которого пользователи могут самостоятельно изменять с помощью инструментов, предоставляемых самим сайтом. Форматирование текста и вставка различных объектов в текст производится с использованием <a href='https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%82%D0%BA%D0%B0' target='_blank'>вики-разметки</a>.<br><br>
Впервые термин «вики» для описания веб-сайта был использован в 1995 году Уордом Каннингемом, разработчиком первой вики-системы WikiWikiWeb, «Портлендского хранилища образцов» программного кода, созданной 25 марта 1995 года, который заимствовал слово гавайского языка, означающее «быстрый».<br><br>
Уорд Каннингем (Ward Cunningham) и его соавтор Бо Леуф (Bo Leuf) в их книге The Wiki Way: Quick Collaboration on the Web (Вики-путь: Живое сотрудничество в сети) описали сущность концепции вики следующим образом:
<ul><li>Вики предлагает всем пользователям редактировать любую страницу или создавать новые страницы на вики-сайте, используя обычный веб-браузер без каких-либо его расширений.</li>
<li>Вики поддерживает связи между разными страницами за счёт почти интуитивно понятного создания ссылок на другие страницы и отображения того, существуют данные страницы или нет.</li>
<li>Вики не является тщательно изготовленным сайтом для случайных посетителей. Напротив, Вики стремится привлечь посетителей к непрерывному процессу создания и сотрудничества, который постоянно меняет вид сайта.</li></ul>
Вики характеризуется такими признаками:
<ul><li>Возможность многократно править текст посредством самой вики-среды (сайта), без применения особых приспособлений на стороне редактора.
<div class=list>Особый язык разметки — так называемая вики-разметка, которая позволяет легко и быстро размечать в тексте структурные элементы и гиперссылки; форматировать и оформлять отдельные элементы.</div>
<div class=list>Учёт изменений (версий) страниц: возможность сравнения редакций и восстановления ранних.</div></li>
<li>Проявление изменений сразу после их внесения.</li>
<li>Разделение содержимого на именованные страницы.
<div class=list>Гипертекст: связь страниц и подразделов сайта через контекстные гиперссылки.</div></li>
<li>Множество авторов. Некоторые вики могут править все посетители сайта.</li></ul><br>
<span style='float:right; margin-top:-16px; background-color:#ffffe8;'><em>(из <a href='https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8' target='_blank'>Википедии</a>)</em>&nbsp;&nbsp;&nbsp;</span></div></div><br>
Весь код и примеры на three.js написаны в стиле кода от <span class=lnk onmouseover="show('Ricardo Cabello - автор <em>three.js</em>')" onmouseout="hide()">Mr.doob</span>. Конечно, можно использовать любой, предпочитаемый вами для работы, стиль, но при добавлении кода в библиотеку или в примеры, требуется следовать этому руководству.
Подробности можно найти <a href="https://github.com/mrdoob/three.js/wiki/Mr.doob%27s-Code-Style%E2%84%A2" target="_blank">здесь</a>.<br><br>

<h2 id="10">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ЧАсто задаваемые ВОпросы</h2>
<h3>Какой формат импорта/экспорта 3D моделей лучше всего поддерживается?</h3>
Рекомендуемым форматом для импорта и экспорта ресурсов является glTF (GL Transmission Format). Потому как этот формат ориентирован на доставку ресурса во время выполнения кода, он компактен для передачи и быстр для загрузки.<br>
Библиотека <em>three.js</em> также предоставляет загрузчики для множества других, популярных форматов, вроде FBX, Collada или OBJ.
Тем не менее, следует в проектах всегда вначале попытаться установить рабочий процесс на основе формата glTF. Более подробную информацию смотрите в описании <a href="#8">загрузки 3D моделей</a>.
<br><br>

<h3>Почему в примерах присутствуют теги meta для окна просмотра (viewport)?</h3>
<pre>&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;</pre>
Эти тэги управляют размерами окна просмотра (viewport) и масштабом для браузеров мобильных телефонов (где содержимое страницы может отображаться в другом размере, чем видимое окно просмотра).<br>
<a href="http://developer.apple.com/library/safari/#documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html" target="_blank">Safari: Using the Viewport</a><br>
<a href="https://developer.mozilla.org/en/Mobile/Viewport_meta_tag" target="_blank">MDN: Using the viewport meta tag (англ.)</a><br>
<a href="https://developer.mozilla.org/ru/docs/Mozilla/Mobile/Viewport_meta_tag" target="_blank">MDN: Использование мета тега viewport (рус.)</a>

<h3>Как можно сохранить масштаб сцены при изменении размера?</h3>
Хочется чтобы все объекты, независимо от их расстояния до камеры, выглядели одинаково, даже при изменении размера окна.
Ключевое уравнение для решения этой задачи - это формула для видимой высоты (visible_height) на заданном расстоянии от камеры (distance_from_camera):
<pre>visible_height = 2 * Math.tan( ( Math.PI / 180 ) * camera.fov / 2 ) * distance_from_camera;</pre>
Если увеличивается высота окна на определенный процент, то и видимая высота на всех расстояниях также увеличивалась на тот же самый процент.
Этого нельзя сделать изменением положения камеры. Вместо этого следует изменять поле просмотра камеры (параметр <tt>fov</tt> - field-of-view).
<a href="http://jsfiddle.net/Q4Jpu/" target="_blank">Пример</a>.

<h3>Почему часть моего объекта невидима?</h3>
Это может происходить из-за выбора грани. У граней имеется ориентир, который определяет какая сторона является передней и видимой, а какая - задней и невидимой.
И в обычных условиях при выборе удаляется задняя, невидимая сторона. Если проблема в этом, измените сторону материала на THREE.DoubleSide.
<pre>material.side = THREE.DoubleSide</pre><br><br>

<h2 id="11">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ссылки на полезные ресурсы</h2>
Ниже приведена коллекция ссылок, которые возможно будут полезными при изучении <em>three.js</em>.<br>
Если вы нашли что-либо, что хочется сюда добавить, или считаете, что одна из приведенных ссылок больше не уместна или не работает, не стесняйтесь кликнуть кнопку 'edit' (редактировать) справа вверху и внести некоторые изменения!<br><br>
Отметьте также, что <em>three.js</em> довольно быстро развивается, многие из этих ссылок будут содержать устаревшие сведения - если что-то работает не так, как ожидалось или как указывается в этой ссылке,
проверьте консоль браузера на наличие предупреждений и ошибок, соответствующие разделы этой справки и особенно страницу <a href="deprecated-list.htm">DeprecatedList</a> (список устаревших элементов API).<br><br>

<h3>Справочные форумы</h3>
<em>three.js</em> официально использует <a href="http://stackoverflow.com/tags/three.js/info" target="_blank">Stack Overflow</a> для запросов справочной информации.<br>
Если в чем-либо требуется помощь, обращайтесь туда. НЕ НУЖНО создавать проблемы просьбами помочь на Github'е.<br><br>

<h3>Учебники и курсы</h3>
<h4>Начало работы с three.js</h4>
<ul><li><a href="https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html" target="_blank">Three.js Fundamentals starting lesson</a> - Основы <em>three.js</em>, начальный урок. Вот этот же <a href="https://threejsfundamentals.org/threejs/lessons/ru/threejs-fundamentals.html" target="_blank">учебник на русском языке</a>.</li>
<li><a href="https://codepen.io/rachsmith/post/beginning-with-3d-webgl-pt-1-the-scene" target="_blank">Beginning with 3D WebGL</a> от <a href="https://codepen.io/rachsmith/" target="_blank">Rachel Smith</a>.</li>
<li><a href="https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/" target="_blank">Animating scenes with WebGL and three.js</a> - анимация сцен с WebGL и <em>three.js</em> от <a href="https://www.linkedin.com/in/mattagar" target="_blank">Matt Agar</a>.</li></ul>

<h4>Более расширенные и дополняющие статьи и курсы</h4>
<ul><li><a href="https://discoverthreejs.com/" target="_blank">Discover three.js</a> - Откройте для себя three.js от <a href="https://twitter.com/lewy_blue" target="_blank">Lewy Blue</a></li>
<li><a href="https://threejsfundamentals.org/" target="_blank">Three.js Fundamentals</a> - Основы <em>three.js</em>. Вот этот же <a href="https://threejsfundamentals.org/threejs/lessons/ru/" target="_blank">курс на русском языке</a>.</li>
<li><a href="http://blog.cjgammon.com/" target="_blank">Collection of tutorials</a> набор учебников от <a href="http://www.cjgammon.com/" target="_blank">CJ Gammon</a>.</li>
<li><a href="https://medium.com/@soffritti.pierfrancesco/glossy-spheres-in-three-js-bfd2785d4857" target="_blank">Glossy spheres in <em>three.js</em></a> блестящие сферы в three.js.</li>
<li><a href="https://www.udacity.com/course/cs291" target="_blank">Interactive 3D Graphics</a> - бесплатный курс по Udacity, обучающий основам 3D графики и использующий в качестве инструмента кодирования <em>three.js</em>.</li>
<li><a href="https://aerotwist.com/tutorials/" target="_blank">Aerotwist</a> учебники от <a href="https://github.com/paullewis/" target="_blank">Paul Lewis</a>.</li>
<li><a href="http://learningthreejs.com/" target="_blank">Learning Three.js</a> – a blog with articles dedicated to teaching three.js</li>
<li><a href="http://bkcore.com/blog/3d/webgl-three-js-animated-selective-glow.html" target="_blank">Animated selective glow in Three.js</a> от <a href="https://github.com/BKcore" target="_blank">BKcore</a></li></ul>

<h3>Новости и обновления</h3>
<ul><li><a href="https://twitter.com/hashtag/threejs" target="_blank"><em>three.js</em> в Twitter'е</a></li>
<li><a href="http://www.reddit.com/r/threejs/" target="_blank"><em>three.js</em> на reddit</a></li>
<li><a href="http://www.reddit.com/r/webgl/" target="_blank">WebGL на reddit</a></li>
<li><a href="http://learningwebgl.com/blog/" target="_blank">Learning WebGL Blog</a> – Авторитетный источник новостей о WebGL.</li></ul>

<h3>Примеры</h3>
<ul><li><a href="https://github.com/edwinwebb/three-seed/" target="_blank">three-seed</a> - шаблон стартового проекта three.js с ES6 и Webpack</li>
<li><a href="http://stemkoski.github.io/Three.js/index.html" target="_blank">Professor Stemkoskis Examples</a> (Примеры профессора Стемкоскис) - Сборник дружественных примеров для начинающих, построенных с использованием <em>three.js</em> версии r60a.</li>
<li><a href="https://threejs.org/examples/" target="_blank">Официальные примеры three.js</a> - эти примеры сохраняются как часть репозитория <em>three.js</em> и всегда используют последнюю версию three.js.</li>
<li><a href="https://rawgit.com/mrdoob/three.js/dev/examples/" target="_blank">Официальные примеры three.js на ветке <tt>dev</tt></a>  -
То же самое, что и выше, за исключением того, что используется ветка <tt>dev</tt> <em>three.js</em>, а примеры используются при разработке для проверки того, как все работает.</li></ul>

<h3>Инструменты</h3>
<ul><li><a href="http://www.physgl.org/" target="_blank">physgl.org</a> - javascript front-end with wrappers to three.js, чтобы донести графику WebGL до студентов, изучающих физику и математику.</li>
<li><a href="https://whs.io/" target="_blank">Whitestorm.js</a> – Модульный фреймворк <em>three.js</em> с физическим плагином AmmoNext.</li>
<li><a href="http://zz85.github.io/zz85-bookmarklets/threelabs.html" target="_blank"><em>three.js</em> Inspector</a></li>
<li><a href="http://idflood.github.io/ThreeNodes.js/" target="_blank">ThreeNodes.js</a>.
<li><a href="https://marketplace.visualstudio.com/items?itemName=bierner.comment-tagged-templates" target="_blank">comment-tagged-templates</a> - VSCode extension syntax highlighting for tagged template strings, like: glsl.js.</li></ul>

<h3>WebGL References</h3>
<ul><li><a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf" target="_blank">https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf</a> - Справочник по всем ключевым словам WebGL и GLSL, терминологии, синтаксису и определениям.</li></ul>


<h3>Старые ссылки</h3>
Эти ссылки хранятся в исторических целях - в них тоже можно найти что-то полезное, но имейте ввиду, содержащаяся в них информация относится к очень старым версиям three.js.
<ul><li><a href="https://www.youtube.com/watch?v=Dir4KO9RdhM">AlterQualia at WebGL Camp 3</a></li>
<li><a href="http://yomotsu.github.io/threejs-examples/" target="_blank"> Yomotsus Examples</a> (примеры) - коллекция примеров, с использованием three.js версии r45.</li>
<li><a href="http://fhtr.org/BasicsOfThreeJS/#1" target="_blank">Introduction to Three.js</a> - введение в Three.js от <a href="http://github.com/kig/" target="_blank">Ilmari Heikkinen</a> (слайдшоу).</li>
<li><a href="http://www.slideshare.net/yomotsu/webgl-and-threejs" target="_blank">WebGL and Three.js</a> от <a href="http://github.com/yomotsu" target="_blank">Akihiro Oyamada</a> (слайдшоу).</li>
<li><a href="http://bkcore.com/blog/general/adobe-user-group-nl-talk-video-hexgl.html" target="_blank">Fast HTML5 game development using three.js</a> от <a href="https://github.com/BKcore" target="_blank">BKcore</a> (видео).</li>
<li><a href="http://www.youtube.com/watch?v=VdQnOaolrPA">Trigger Rally</a>  от <a href="https://github.com/jareiko" target="_blank">jareiko</a> (видео).</li>
<li><a href="http://blackjk3.github.io/threefab/" target="_blank">ThreeFab</a> - редактор сцен, поддерживался приблизительно до three.js версии r50.</li>
<li><a href="http://bkcore.com/blog/3d/webgl-three-js-workflow-tips.html" target="_blank">Max to Three.js workflow tips and tricks</a> от <a href="https://github.com/BKcore" target="_blank">BKcore</a></li>
<li><a href="http://12devsofxmas.co.uk/2012/01/webgl-and-three-js/" target="_blank">A whirlwind look at Three.js</a> (Беглый взгляд на Three.js) от <a href="http://github.com/nrocy" target="_blank">Paul King</a></li>
<li><a href="http://bkcore.com/blog/3d/webgl-three-js-animated-selective-glow.html" target="_blank">Animated selective glow in Three.js</a> от <a href="https://github.com/BKcore" target="_blank">BKcore</a></li>
<li><a href="http://www.natural-science.or.jp/article/20120220155529.php" target="_blank">Building A Physics Simulation Environment</a> построение среды моделирования физических процессов - учебник three.js на японском</li></ul>

<br><br>
</body></html>
