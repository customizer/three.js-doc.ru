<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Three.js</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>
<body>
<h2 class=head1>Введение</h2>
<h1 id="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Создание сцены</h1>
Цель этого раздела - дать краткое вступление в <em>three.js</em>. Начнем его созданием сюжета с вращающимся кубом. На случай если вы запутаетесь и понадобится помощь, рабочий пример кода <a href="#1.2">приводится ниже</a>.
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Прежде чем начать</h3>
Перед использованием <em>three.js</em>, нужно определиться, где мы будем его показывать. Сохраните следующий HTML-код как файл на своем компьютере вместе с копией файла <tt><a href="http://threejs.org/build/three.js" target="_blank">three.js</a></tt> в папке <tt>js/</tt> и откройте его в своем браузере.
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=utf-8&gt;
    &lt;title&gt;My first Three.js app&lt;/title&gt;
    &lt;style&gt;
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
      &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="js/three.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      // Здесь будет ваш Javascript код.
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
Это все. Весь код ниже идет в пустой тег <tt>&lt;script&gt;</tt>.

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Создание сцены</h3>
Для того, чтобы была возможность что-либо отображать с <em>three.js</em>, нужны три вещи: сцена (scene), камера (camera) и визуализатор (renderer) - также называемый рендерер (по звучанию английского слова), чтобы была возможность показывать сцену, снятую камерой.
<pre>var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );<br>
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );</pre>
Давайте воспользуемся моментом и поясним, что здесь происходит. На данном этапе у нас имеется набор из сцены (переменная <tt>scene</tt>), камеры (переменная <tt>camera</tt>) и визуализатора (переменная <tt>renderer</tt>).
В <em>three.js</em> имеется несколько разных камер. Сейчас мы будем использовать PerspectiveCamera (т.е. камеру с отображением перспективы). Первым параметром у нее является
<a href="#" onclick="return false" onmouseover="show('сокращение от англ. слов field of view - поле зрения или просмотра - угол,<br>которым ограничена зона видимости камеры, объекты не попадающие<br>'
+'в нее не будут видны.<br>Различают поле зрения по горизонтали и по вертикали.<br>В three.js угол fov - это поле зрения по вертикали и измеряется в градусах.');" onmouseout="hide()">fov</a> (поле зрения или просмотра).<br><br>
Второй параметр - это <a href="#" onclick="return false" onmouseover="show('сокращение от англ. слов<br>aspect ratio - отношение сторон');" onmouseout="hide()">aspect</a> (соотношение сторон, пропорции или формат кадра).
Почти всегда нужно использовать отношение ширины элемента к его высоте или получите такой же результат как при просмотре старых фильмов на широкоэкранных телевизорах - изображение будет выглядеть сплющенным.<br><br>
Следующими двумя параметрами являются <a href="#" onclick="return false" onmouseover="show('от англ. слова near - возле, близко');" onmouseout="hide()">near</a> (ближняя)
и <a href="#" onclick="return false" onmouseover="show('от англ. слова far - далеко');" onmouseout="hide()">far</a> (дальняя) плоскости отсечения.
Это значит, что объекты дальше, чем значение <b>far</b> или ближе, чем <b>near</b> не будут показаны.
Пока о  них можно не беспокоиться, но для увеличения быстродействия в своем приложении можно использовать другие значения.
<div class=note_trans><b>Примечание переводчика:</b> как говорится "вместо тысячи слов", вот на рисунке показаны все параметры камеры.<br><a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>
<img src="img/1.png" width="600"><br>
Как видите, для камеры задается поле просмотра или поле видимости камеры (параметр field of view) в градусах и трехмерное пространство - соотношение ширины и высоты (в параметре aspect ratio) и глубина (в параметрах near и far).</div></div>
Далее идет визуализатор (рендерер). Вот тут то и происходит волшебство.
В дополнение к используемому здесь WebGLRenderer, в Three.js имеется несколько других, зачастую используемых в качестве резервного варианта для пользователей со старыми браузерами или тех, у кого нет поддержки WebGL по другим причинам.<br><br>
Помимо создания экземпляра визуализатора (рендерера), также нужно установить размеры в которых будет отображаться наше приложение.
Хорошей идеей будет использование ширины и высоты области, которую нам хочется занять нашим приложением - в данном случае, это ширина и высота элемента &lt;canvas&gt;, т.е. полный размер (помните, у &lt;canvas&gt; и ширина (width) и высота (height) равны 100%) окна браузера.
При выполнении ресурсоёмких приложений также можно задать параметру <b>setSize</b> меньшие значения, вроде <b>window.innerWidth/2</b> и <b>window.innerHeight/2</b>, которые сделают визуализацию приложения в половинном размере.<br><br>
Если нужно сохранить размеры приложения, но отобразить его с более низким разрешением, можно сделать это, вызвав параметр <b>setSize</b> со значением false в качестве параметра <b>updateStyle</b>.<br>
Например, код <tt>setSize(window.innerWidth/2,&nbsp;window.innerHeight/2,&nbsp;false)</tt> сделает визуализацию приложения в половинном разрешении, с учетом того, что наш &lt;canvas&gt; имеет 100% ширину и высоту от размеров окна браузера.<br><br>
И наконец, что не менее важно, к нашему HTML-документу добавляем элемент <b>renderer</b>'а. Это элемент &lt;canvas&gt;, на котором рендерер и отображает сцену.<br><br>
<em>Так то все хорошо, но где этот обещанный куб?</em><br>Сейчас мы его добавим.<br><br>
<pre>var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );<br>
camera.position.z = 5;</pre>
Для создания куба нам потребуется <b>BoxGeometry</b>, т.е. геометрия куба.
Это объект, содержащий все точки (вершины - <b>vertices</b> ед. число vertex) и стороны (грани - <b>faces</b>) куба. В дальнейшем мы рассмотрим это более подробно.
<div class=note_trans><b>Примечание переводчика:</b> Здесь и далее слово &#171;геометрия&#187; означает совокупность всех геометрических свойств объекта,
т.е. все элементы, которые составляют каркас объекта - вершины, грани, а также их цвет и расположение.<br><a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>Кроме того, слово грани (в английском варианте это faces, или face в единственном числе) в данной справке имеет двойной смысл: грань - в смысле сторона трехмерной геометрической фигуры и грань - ячейка-треугольник каркаса объекта.<br>
<img src="img/BoxGeometry1.png" width="300"><br>
Получается что грань объекта-куба состоит из треугольных граней ячеек каркаса.<br>
Далее в справке гранью будет называться именно ячейка каркаса, в случае грани, как стороны объекта, будет дополнительное описание, например грань куба.</div></div>
В дополнение к геометрии куба понадобится и материал для его окрашивания. В Three.js имеется несколько материалов, но в данном случае будем использовать <b>MeshBasicMaterial</b>.
Все материалы принимают свойства объекта, что были к нему применены. Чтобы сохранить простоту вещей, предоставим только атрибут цвета <b>0x00ff00</b>, т.е. зеленый цвет. Это работает точно также как в CSS или Photoshop (шестнадцатиричные значения цвета).<br><br>
Третья вещь, что нам потребуется, это <b>Mesh</b>, т.е. сетка. Mesh представляет собой объект, который принимает геометрию и применяет к ней материал, который потом можно вставить в нашу сцену и свободно перемещаться вокруг.<br><br>
По умолчанию, при вызове <tt>scene.add()</tt>, добавляемая нами вещь будет располагаться в координатах <b>(0,0,0)</b>. Чтобы этого избежать, мы в последней строке просто немножко смещаем камеру.

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Визуализация (рендеринг) сцены</h3>
Если скопировать код, приведенный выше, и вставить в заранее созданный HTML-файл, то вы ничего не увидите. Потому что на самом деле пока еще нечего отображать. Для того, чтобы что-нибудь появилось нужно то, что называется <b>render loop</b> - циклом визуализации.
<pre>function render() {
	requestAnimationFrame( render );
	renderer.render( scene, camera );
}
render();</pre>
Этот код создаст цикл, который будет 60 раз в секунду вызывать визуализатор для прорисовки сцены. Если вы новичок в написании браузерных игр, то можете сказать: "Почему бы нам просто не вызвать JavaScript-функцию <a href="#" onclick="return false" onmouseover="show('set interval - установка интервала,<br>т.е. времени между вызовами функции перерисовки сцены');" onmouseout="hide()"><tt>setInterval</tt></a>?"
Конечно же, можно это сделать, но у функции <a href="#" onclick="return false" onmouseover="show('request animation frame - запрос кадра анимации<br>- позволяет синхронизировать все анимации со<br>встроенными механизмами обновления страницы.<br><br>То есть, сгруппированы будут не только JavaScript-анимации,<br>но и CSS-анимации и другие браузерные перерисовки. При этом<br>графический ускоритель используется максимально эффективно<br>и исключается повторная обработка одних и тех же участков<br>страницы.<br>А значит – меньше будет загрузка CPU, да и сама анимация<br>станет более плавной.');" onmouseout="hide()"><tt>requestAnimationFrame</tt></a> имеется несколько преимуществ.
Пожалуй, самым важным из них является то, что анимация приостанавливается при переходе пользователя на другую вкладку браузера, а следовательно не тратится драгоценная вычислительная мощность и заряд аккумулятора.<br><br>
<div class=note_trans><b>Примечание переводчика:</b> Вот ещё одна картинка для лучшего понимания процесса визуализации в three.js.<br><a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>
<img src="img/2.png" width="400" align="right"><br>
Это так называемый <a href="#" onclick="return false" onmouseover="show('Граф — абстрактный математический объект, представляющий из себя<br>множество вершин графа и набор рёбер, то есть соединений между парами вершин.<br>Для разных областей применения виды графов могут различаться направленностью,<br>ограничениями на количество связей и дополнительными данными о вершинах<br>или рёбрах.<br>Многие структуры, представляющие практический интерес в математике<br>и информатике, могут быть представлены графами.');" onmouseout="hide()">граф</a>,
т.е. в нашем случае - совокупность всех объектов, участвующих в визуализации, и связи между ними.<br><br>

Геометрические параметры объекта (т.е. каркас) или попросту "геометрия" - Geometry, составленная из Vertex (вершин) и Face3 (граней-треугольников), передаётся в Mesh (сетку).<br>
Сюда же поступает и Material (материал), который создается после преобразования изображения (Image) в текстуру (Texture).
<br><br>
Грубо говоря, каркас (Geometry) "обтягивается" материалом (Material) при помощи сетки (Mesh). Причем сетка уже является элементом сцены, то есть, её то мы и будем видеть на объекте.<br><br>
Кроме сетки, на сцене находятся освещение и камера. Ну с освещением все понятно, его функция освещать сцену и объекты на ней, а вот с камерой несколько сложнее. Ей задаются параметры, с которыми она должна смотреть на сцену, и передаются в визуализатор или рендерер (renderer). Камеру можно перемещать.<br><br>
Также в рендерер передается и сцена со всеми объектами, находящимися на ней, т.е. вид (или представление, визуализация - render). В этом представлении на сцене, если требуется, можно задать перемещение объектов или всей сцены, т.е. их анимацию.<br><br>
Рендерер показывает нам на &lt;canvas&gt; получившуюся картинку, то есть освещенную сцену с объектами на ней с точки зрения камеры.<br><br>
<span style='float:right; margin-top:-16px; background-color:#ffffe8;'><em>(картинка <a href='http://davidscottlyons.com/threejs/presentations/frontporch14/index.html#slide-16' target='_blank'>отсюда</a>)</em>&nbsp;&nbsp;&nbsp;</span><br></div></div>

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Анимация куба</h3>
Если весь код, приведенный выше, вставлен в заранее созданный файл, вы должны увидеть зеленый куб. Давайте сделаем его чуть поинтереснее - покрутим его.<br><br>
Добавьте следующий код сразу перед вызовом <b>renderer.render</b> функции <b>render</b>:
<pre>cube.rotation.x += 0.1;
cube.rotation.y += 0.1;</pre>
Этот код будет выполняться в каждом кадре (60 раз в секунду) и задаст кубу хорошую анимацию вращения. В принципе, все что нужно перемещать или изменять во время работы приложения, должно проходить через цикл рендеринга.
Конечно, там можно вызвать и другие функции, но постарайтесь не делать функцию <b>render</b> в несколько сотен строк.

<h3 id="1.2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Итог</h3>
Поздравляем! Вы только что получили свое первое <em>three.js</em> приложение. Как видите, просто нужно было где-то начать.<br><br>
Полный код показан ниже. Чтобы получить более полное представление о его работе,  поиграйтесь с ним (т.е. попробуйте поменять те или иные параметры и понаблюдайте за получающимися изменениями).
<div class="blockindent"><b>Код:</b> <a class='link' onclick='javascript:spoiler1(this)'>... показать</a>
<div style='display:none;'>
<pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My first Three.js app&lt;/title&gt;
    &lt;style&gt;
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="js/three.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );<br>
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );<br>
      var geometry = new THREE.BoxGeometry( 1, 1, 1 );
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      var cube = new THREE.Mesh( geometry, material );
      scene.add( cube );<br>
      camera.position.z = 5;<br>
      var render = function () {
        requestAnimationFrame( render );<br>
        cube.rotation.x += 0.1;
        cube.rotation.y += 0.1;<br>
        renderer.render(scene, camera);
      };<br>
      render();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><br><br>

<h2 id="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Импорт с помощью модулей</h2>
Несмотря на то, что импорт <em>three.js</em> с помощью тега <tt>&lt;script&gt;</tt> отличный способ быстро получить и начать работать с библиотекой, у него имеется несколько недостатков для продолжительных проектов, например:
<ul><li>Нужно вручную выбирать и подключать копию библиотеки как часть исходного кода проекта.</li>
<li>Обновление версии библиотеки также "ручной" процесс.</li>
<li>При проверке новой версии данной библиотеки управление различия в управлении версиями завалены множеством строк сборочного файла.</li></ul>
Использование диспетчера зависимостей типа <tt>npm</tt> обходит эти условия позволяя просто скачивать и импортировать желаемую версию библиотеки на вашу машину.
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Установка при помощи <tt>npm</tt></h3>
<div class=note_trans><b>Примечание переводчика:</b> npm - сокращ. от Node.js Package Manager — менеджер пакетов, входящий в состав <a href='https://ru.wikipedia.org/wiki/Node.js' target='_blank'>Node.js</a></div>
<em>three.js</em> выпускается как модуль <a href="https://www.npmjs.com/package/three" target="_blank"><tt>npm</tt></a>.
Это значит, что для включения <em>three.js</em> в проект, нужно просто запустить "<tt>npm install three</tt>".
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Импорт модуля</h3>
Предположим, что вы объединяете файлы с помощью такого инструмента как <a href="https://webpack.github.io/" target="_blank">Webpack</a> или <a href="https://github.com/substack/node-browserify" target="_blank">Browserify</a>,
которые позволяют "<tt class=lnk onmouseover="show('require(&quot;modules&quot;) - затребовать модули')" onmouseout="hide()">require('modules')</tt> в браузере, объединив все свои зависимости".
Теперь можно внести модуль в свои исходные файлы и продолжить использовать его в обычном режиме.
<pre>var THREE = require('three');<br>
var scene = new THREE.Scene();
...</pre>
Также есть возможность использования импорта синтаксиса ES6:
<pre>import * as THREE from 'three';<br>
const scene = new THREE.Scene();
...</pre>
или, если хотите импортировать только отдельные части библиотеки <em>three.js</em>, например <tt>Scene</tt>:
<pre>import { Scene } from 'three';<br>
const scene = new Scene();
...</pre>
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Предостережения</h3>
В настоящее время таким способом невозможно импортировать файлы в каталог "<tt>examples/js</tt>". Это происходит из-за того, что некоторые из файлов зависимы от загрязнения глобального пространства имен THREE.
Более подробные сведения смотрите на <a href="https://github.com/mrdoob/three.js/issues/9562" target="_blank">Transform `examples/js` to support modules #9562</a>.<br><br>

<h2 id="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Поддержка браузерами</h2>
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Обзор</h3>
Three.js может использовать WebGL для визуализации (рендеринга) сцен во всех современных браузерах.
Для старых браузеров, особенно Internet Explorer 10 и ниже, может потребоваться откат к одному из оставшихся <a href="https://github.com/mrdoob/three.js/tree/master/examples/js/renderers" target="_blank">визуализаторов (рендереров)</a> (CSS2DRenderer, CSS3DRenderer, SVGRenderer, CanvasRenderer).
Кроме того, может потребоваться включение некоторых полифиллов, особенно при использовании файлов из каталога <a href="https://github.com/mrdoob/three.js/tree/master/examples" target="_blank"><tt>/examples</tt></a>.
<div class=note_trans>«Полифилл» (англ. «polyfill» - poly - много, fill - наполнять, заполнять) <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'> — это библиотека, которая добавляет в старые браузеры поддержку возможностей, которые в современных браузерах являются встроенными.
Или, если говорить о современных браузерах, то они тоже не все идут «в ногу», всегда какие-то современные возможности реализуются сначала в одном, потом в другом.
Так вот, первая часть слова говорит о привлечении любого числа технологий, то есть с поставленной задачей можно справиться не только посредством JavaScript, а вторая часть подразумевает заполнение той «дыры» браузера, в которой и должна находиться реализуемая таким образом технология.<br><br>
Полифиллы позволяют исправлять ошибки в конкретном API или добавлять в веб-браузер функционал, который по умолчанию частично или полностью им не поддерживается. Полифиллы не создают лишних зависимостей и могут быть легко удалены, когда они больше не нужны.<br>
Обычно полифилл состоит из двух частей:
<div class=blockindent>Проверка, есть ли встроенная возможность.<br>Эмуляция, если её нет.</div>
По мнению <a href="#" onclick="return false" onmouseover="show('Термин был придуман Реми Шарпом (англ. Remy Sharp) в 2009 году<br>во время работы над книгой «Введение в HTML5»');" onmouseout="hide()">автора термина</a>,
ассоциация с заделыванием трещин и дыр в стенах вполне подходит для визуализации того, как полифиллы в веб-программировании «ремонтируют» браузер.</div></div>
<div class=note><b>Примечание:</b> если поддержка устаревших браузеров не требуется, то не рекомендуется использовать другие визуализаторы-рендереры, отличные от WebGLRenderer, так как они работают медленнее и поддерживают меньшее количество функций.</div>

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Браузеры, поддерживающие WebGL</h3>
WebGL поддерживается следующими браузерами: Google Chrome 9+, Firefox 4+, Opera 15+, Safari 5.1+, Internet Explorer 11 и Microsoft Edge.
Узнать, какие браузеры поддерживают WebGL можно на <a href="https://caniuse.com/#feat=webgl" target="_blank" onmouseover="show('название сайта переводится как<br>&#171;могу ли я пользоваться WebGL&#187;');" onmouseout="hide()">Can I use WebGL</a>.

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Используемые в three.js функции на языке JavaScript или Web API</h3>
Вот несколько функций, используемых в <em>three.js</em>. Для некоторых из них может потребоваться дополнение полифиллами.
<table class="tbl_1" border="1" cellpadding="5" width="90%">
<tr class="head"><td>функции<br>Feature</td><td>область&nbsp;применения<br>Use Scope</td><td>модули<br>Modules</td></tr>
<tr valign="top"><td>Typed Arrays </td><td>Исходник</td><td>BufferAttribute, BufferGeometry и т.д.</td></tr>
<tr valign="top"><td>Web Audio API</td><td>Исходник</td><td>Audio, AudioContext, AudioListener и т.д.</td></tr>
<tr valign="top"><td>WebVR API</td><td>Исходник</td><td>WebVRManager и т.д.</td></tr>
<tr valign="top"><td>Blob</td><td>Исходник</td><td>FileLoader, etc.</td></tr>
<tr valign="top"><td>Promise</td><td>Примеры</td><td>GLTFLoader, GLTF2Loader, WebVR, VREffect и т.д.</td></tr>
<tr valign="top"><td>Fetch</td><td>Примеры</td><td>ImageBitmapLoader и т.д.</td></tr>
<tr valign="top"><td>File API</td><td>Примеры</td><td>GLTFExporter и т.д.</td></tr>
<tr valign="top"><td>URL API</td><td>Примеры</td><td>GLTFLoader и т.д.</td></tr>
<tr valign="top"><td>Pointer Lock API </td><td>Примеры</td><td>PointerLockControls</td></tr></table><br>

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Полифиллы</h3>
Просто импортируйте полифиллы, исходя из своих требований. Если в качестве примера взять IE9, то потребуются полифиллы как минимум к этим функциям:
<ul><li>Typed Arrays</li>
<li>Blob</li></ul>
Рекомендуемые полифиллы
<ul><li><a href="https://github.com/zloirock/core-js" target="_blank">core-js</a></li>
<li><a href="https://github.com/inexorabletash/polyfill/blob/master/typedarray.js" target="_blank">typedarray.js</a></li>
<li><a href="https://github.com/stefanpenner/es6-promise/" target="_blank">ES6-Promise</a></li>
<li><a href="https://github.com/eligrey/Blob.js" target="_blank">Blob.js</a></li>
<li><a href="https://github.com/github/fetch" target="_blank">fetch</a></li></ul><br><br>



<h2 id="4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Обнаружение совместимости браузера с WebGL</h2>
Несмотря на то, что проблема встречается все реже и реже, некоторые устройства или браузеры все ещё не могут работать с WebGL.<br>
Описанный ниже метод проверяет, поддерживается ли WebGL и, если это не так, выводит сообщение пользователю.<br><br>
Добавьте с своему javascript-коду <a href="https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js" target="_blank">Detector.js</a> и запускайте следующий код прежде чем пытаться что-либо отобразить.
<pre>if (Detector.webgl) {
  // Initiate function or other initializations here
  // Здесь располагается инициализация функции или другие инициализации
    animate();
} else {
    var warning = Detector.getWebGLErrorMessage();
    document.getElementById('container').appendChild(warning);
}</pre><br><br>

<h2 id="5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Как все это запустить локально</h2>
Если используются только конструкции, предусмотренные в Three.js, и никаких текстур дополнительно не загружается, веб-страницы должны работать прямо из файловой системы, просто сделайте двойнок клик в файловом менеджере по HTML файлу и он должен появиться и начать работать в браузере (в адресной строке будет видно <tt>file:///yourFile.html</tt>).

<h3>Содержимое, загружаемое из внешних файлов</h3>
Если модели или текстуры загружаются из внешних файлов, из-за ограничений безопасности по
<a href="#" onclick="return false" onmouseover="show('Правило ограничения домена (Same Origin Policy, в переводе<br>с англ. «Принцип одинакового источника») — это важная<br>концепция безопасности для некоторых языков программирования<br>на стороне клиента, таких как JavaScript.<br>'
+'Политика разрешает сценариям, находящимся на страницах<br>одного сайта, доступ к методам и свойствам друг друга без<br>ограничений, но предотвращает доступ к большинству методов<br>и свойств для страниц на разных сайтах.<br>'
+'Одинаковые источники — это источники, у которых совпадают<br>три признака: домен, порт, протокол.');" onmouseout="hide()">правилу ограничения домена</a>
браузера, загрузка из файловой системы завершится ошибкой и выдачей сообщения с описанием исключения безопасности.
<div class=note_trans><b>Примечание переводчика:</b> Вот ссылки на статьи в Википедии про <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B0" target="_blank">Правило ограничения домена</a> и <a href="http://en.wikipedia.org/wiki/Same_origin_policy" target="_blank">Same Origin Policy</a>.</div>
Существует два способа решения этой проблемы:
<ol><li>Изменить для локальных файлов правила безопасности в браузере. Это позволит получить доступ к своей странице как: <tt>file:///yourFile.html</tt></li>
<li>Запускать файлы из локального веб-сервера. Это позволит получить доступ к своей странице как: <tt>http://localhost/yourFile.html</tt></li></ol>
При использовании первого варианта имейте в виду, что если используете тот же самый браузер и для обычного веб-серфинга, можно открыть некоторые уязвимости.
Для безопасности, можно создать отдельный профиль/ярлык браузера только для локального применения. Давайте рассмотрим каждый вариант по очереди.<br><br>

<h3>Изменение политики безопасности локальных файлов в браузере</h3>
<h4>Safari</h4>
<div class="blockindent">С помощью панели настройки включите меню разработки, через Advanced (дополнительно) <tt>=&#62;</tt> "Show develop menu in menu bar" (показывать меню разработки в панели меню).<br><br>
Затем в меню "Develop" (разработка) браузера выберите "Disable local file restrictions" (отключить ограничения локальных файлов), стоит также отметить, что Safari имеет несколько странное поведение при работе с кэшем,
так что в том же меню желательно использовать опцию "Disable caches" (отключить кэш); если редактирование и отладка ведуться с помощью Safari.</div>

<h4>Chrome</h4>
<div class="blockindent">Вначале закройте все работающие экземпляры браузера Chrome. Главное слово здесь "все".<br><br>
В операционной системе Windows можно проверить число используемых экземпляров Chrome через Панель задач. Кроме того, если в системном трее видно иконку Chrome, можно открыть его контекстное меню и кликнуть 'Exit' - выйти. Это должно закрыть все экземпляры браузера Chrome.<br><br>
Затем запустите исполняемый файл Chrome с флагом командной строки:
<pre>chrome --allow-file-access-from-files</pre>
В ОС Windows, возможно, самым простым способом является создание специального ярлыка, в котором добавлен флаг, указанный выше
(правый клик по иконке ярлыка вызовет контекстное меню, в котором нужно сделать левый клик на строке Свойства (Properties). В открывшемся окне свойств ярлыка, в строке Объект (Target) и нужно добавить упомянутый флаг).<br><br>
В операционной системе Mac OSX это делается с помощью
<pre>open /Applications/Google\ Chrome.app --args --allow-file-access-from-files</pre></div>

<h4>Firefox</h4>
<ol><li>Наберите в адресной строке <tt>about:config</tt></li>
<li>Найдите параметр <tt>security.fileuri.strict_origin_policy</tt></li>
<li>Установите его как <em>false</em></li></ol><br><br>

<h3>Запуск локального сервера</h3>
На многих языках программирования имеются встроенные простые HTTP-серверы.
Они не настолько полнофункциональны, как реально работающие сервера, подобные <a href="https://www.apache.org/" target="_blank">Apache</a> или <a href="https://nginx.org" target="_blank">NGINX</a>, тем не менее они должны быть достаточны для тестирования приложения three.js.<br>
<div>
<h4>Запуск сервера Python</h4>
<div class="blockindent">Если установлен <a href="http://python.org/" target="_blank">Python</a>, то его должно быть достаточно для запуска сервера из командной строки (из рабочего каталога):
<pre>//Python 2.x
python -m SimpleHTTPServer<br>
//Python 3.x
python -m http.server</pre>
Он будет обслуживать файлы из текущего каталога в localhost по 8000 порту, то есть, в адресной строке наберите:
<pre>http://localhost:8000/</pre></div><br>

<h4>Запуск сервера Ruby</h4>
<div class="blockindent">Если установлен Ruby, можно получить тот же результат, запустив взамен следующее:
<pre>ruby -r webrick -e "s = WEBrick::HTTPServer.new(:Port => 8000, :DocumentRoot => Dir.pwd); trap('INT') { s.shutdown }; s.start"</pre></div><br>

<h4>Запуск сервера PHP</h4>
<div class="blockindent">В PHP также имеется встроенный сервер, начиная с версии php 5.4.0:
<pre>php -S localhost:8000</pre></div><br>

<h4>Запуск сервера Node.js</h4>
<div class="blockindent">В Node.js имеется простой пакет HTTP сервера. Для установки:
<pre>npm install http-server -g</pre>
Для запуска (из локального каталога):
<pre>http-server . -p 8000</pre></div><br>

<h4>Запуск сервера lighttpd на Mac</h4>
<div class="blockindent">Lighttpd - это очень легковесный веб-сервер общего назначения. Сейчас расскажем о его установке на OSX с помощью HomeBrew.
В отличие от других серверов, обсуждаемых здесь, lighttpd - это полноценный сервер, готовый к реальной работе.
<ol><li>Устанавливаем сервер через homebrew
<pre>brew install lighttpd</pre></li>
<li>В каталоге, где нужно запустить веб-сервер, создаем файл настройки с названием lighttpd.conf. <a href="http://redmine.lighttpd.net/projects/lighttpd/wiki/TutorialConfiguration" target="_blank">Вот здесь</a> имеется пример.</li>
<li>В файле настройки заменяем значение параметра server.document-root на каталог, в котором нужно обслуживать файлы.</li>
<li>Запускаем его
<pre>lighttpd -f lighttpd.conf</pre></li>
<li>Переходим на http://localhost:3000/ и он будет обслуживать статические файлы из выбранного каталога.</li></ol></div><br>
Другие простейшие варианты обсуждаются например на <a href="http://stackoverflow.com/q/12905426/24874" target="_blank">Stack Overflow</a>.</div><br><br>

<h2 id="5a">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Как использовать WebGL2</h2>
Начиная с версии <tt>R95</tt>, движок <em>three.js</em> поддерживает визуализацию (рендеринг) с помощью WebGL 2. По умолчанию, при создании экземпляра WebGLRenderer всегда используется контекст WebGL 1.
Если требуется использовать контекст WebGL 2, ознакомьтесь со следующей последовательностью действий.<br><br>

<h4>Последовательность выполняемых действий</h4>
Поскольку WebGL 2 поддерживается не всеми устройствами, поддерживающими WebGL 1, важно проверить соответствующую возможность. Для этого необходимо включить в проект <a href="https://github.com/mrdoob/three.js/blob/master/examples/js/WebGL.js" target="_blank">WebGL.js</a>.
<pre><script src="/path/to/WebGL.js"></script></pre>
Затем, для выполнения проверки на доступность WebGL 2, используйте следующий код:
<pre>if ( WEBGL.isWebGL2Available() === false ) {
  document.body.appendChild( WEBGL.getWebGL2ErrorMessage() );
}</pre>
Теперь пришло время создать визуализатор (рендерер), применяя элемент HTML5 <tt>canvas</tt> и соответствующий контекст WebGL 2 в конструкторе WebGLRenderer.
В итоге, <em>three.js</em> внутри себя будет использовать для визуализации данный контекст и автоматически сконвертирует шейдерный код встраиваемого материала в код GLSL ES 3.00.
<pre>var canvas = document.createElement( 'canvas' );
var context = canvas.getContext( 'webgl2' );
var renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );</pre>
Иногда требуется написать собственный код шейдера. В качестве основы для своей собственной реализации используйте следующий шаблон кода. Во-первых, код GLSL ES 3.00.
<pre>&lt;script id="vs" type="x-shader/x-vertex">
#version 300 es<br>
void main() {
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
&lt;/script>
&lt;script id="fs" type="x-shader/x-fragment">
#version 300 es<br>
precision highp float;
precision highp int;
out vec4 out_FragColor;<br>
void main() {
  out_FragColor = vec4( 1.0 );
}
&lt;/script></pre>
А во-вторых, код создания соответствующего материала на JavaScript.
<pre>var material = new THREE.ShaderMaterial( {
	vertexShader: document.getElementById( 'vs' ).textContent.trim(),
	fragmentShader: document.getElementById( 'fs' ).textContent.trim()
} );</pre><br>

<h4>Дальнейшие действия</h4>
Посмотрите на один из официальных примеров, чтобы увидеть в действии функции WebGL 2.
<pre><a href="https://threejs.org/examples/#webgl2_materials_texture3d" target="_blank">WebGL2 / materials / texture3d</a>
<a href="https://threejs.org/examples/#webgl2_materials_texture3d_volume" target="_blank">WebGL2 / materials / texture3d / volume</a></pre><br>

<h4>Поддерживаемые функции</h4>
В настоящий момент движок поддерживает только часть всех существующих функций WebGL 2. В списке ниже представлен обзор того, что уже доступно в последней версии <em>three.js</em>.
<ul><li>3D Textures</li></ul>
<br><br>

<h2 id="6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Рисование линий</h2>
Предположим, нужно нарисовать линию или круг, без каркасной <a href="objects.htm#8" onmouseover="show('Mesh')" onmouseout="hide()">сетки</a>.
Вначале нужно установить <a href="renderers.htm" onmouseover="show('WebGLRenderer')" onmouseout="hide()">рендерер (визуализатор)</a>, <a href="scenes.htm#3">сцену</a> и камеру (смотрите страницу <a href="#1">Создание сцены</a>).<br><br>
Вот код, который для этого будет использоваться:
<pre>var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);<br>
var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
camera.position.set(0, 0, 100);
camera.lookAt(new THREE.Vector3(0, 0, 0));<br>
var scene = new THREE.Scene();</pre>
Следующее, что нужно сделать, это определить материал. Для линий можно использовать <a href="materials.htm#1">LineBasicMaterial</a> или <a href="materials.htm#2">LineDashedMaterial</a>.
<pre>//create a blue LineBasicMaterial (создадим синий LineBasicMaterial)
var material = new THREE.LineBasicMaterial({ color: 0x0000ff });</pre>
После определения материала нужно определиться с <a href="core.htm#7">Geometry</a> или <a href="core.htm#2">BufferGeometry</a> с некоторым количеством вершин
(рекомендуется использовать BufferGeometry как более производительную, однако для упрощения здесь будет использована Geometry):
<pre>var geometry = new THREE.Geometry();
geometry.vertices.push(new THREE.Vector3(-10, 0, 0));
geometry.vertices.push(new THREE.Vector3(0, 10, 0));
geometry.vertices.push(new THREE.Vector3(10, 0, 0));</pre>
Обратите внимание, что линии проведены между каждой последующей парой вершин, но не между первой и последней (то есть, эта линия не замкнута).<br><br>
Теперь, когда есть точки для двух линий и материал, можно сложить все вместе для формирования линии.
<pre>var line = new THREE.Line(geometry, material);</pre>
Все что осталось, вывести (добавить) её на сцену и вызвать <a href="renderers.htm#method_render" onmouseover="show('WebGLRenderer.render')" onmouseout="hide()">рендерер</a>.
<pre>scene.add(line);
renderer.render(scene, camera);</pre>
Теперь вы должны увидеть стрелку из двух синих линий, направленную вверх.<br><br>

<h2 id="7">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Создание текста</h2>
Часто бывает так, что в приложении three.js нужно использовать текст - вот несколько способов, как можно это сделать.

<h3>1. DOM + CSS</h3>
Использование HTML - это наиболее простой и быстрый способ добавления текста. Этот метод используется для прилагаемых изображений к большинству примеров <em>three.js</em>.<br><br>
Можно добавить содержимое в
<pre>&lt;div id="info"&gt;Description&lt;/div&gt;</pre>
и использовать CSS-разметку для размещения в абсолютно независимой позиции и поверх всего остального по z-индексу, особенно если приложение three.js работает в полноэкранном режиме.
<pre>#info {
	position: absolute;
	top: 10px;
	width: 100%;
	text-align: center;
	z-index: 100;
	display:block;
}</pre>

<h3>2. Нарисовать текст на canvas и использовать его как <a href="textures.htm#6" onmouseover="show('Texture')" onmouseout="hide()">текстуру</a></h3>
Используйте этот способ, если хочется просто нарисовать текст на плоскости, на своей three.js-сцене.

<h3>3. Создать модель текста в выбранной вами программе 3D-графики<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;и экспортировать её в three.js</h3>
Используйте этот способ, если предпочитаете работать со своей программой 3D-графики и вставьте эту модель в three.js.

<h3>4. Procedural Text Geometry</h3>
Если предпочитаете работать исключительно в three.js или создавать procedural and dynamic 3D текстовые геометрические элементы,
можно создать сетку, геометрические элементы которой являются экземпляром THREE.TextGeometry:
<pre>new THREE.TextGeometry( text, parameters );</pre>
Для того, чтобы это сработало, для TextGeometry будет нужен экземпляр THREE.Font, установленный в качестве значения его параметра "font" - шрифт.
Посмотрите страницу <a href="geometries.htm#34" onmouseover="show('TextGeometry')" onmouseout="hide()">TextGeometry</a> для получения дополнительных сведений о том, как это можно сделать с описанием каждого принимаемого параметра и списком <a href="https://ru.wikipedia.org/wiki/JSON" target="_blank" onmouseover="show('сокращение от англ. слов JavaScript Object Notation<br>(обычно произносится как джейсэн) — текстовый формат<br>обмена данными, основанный на JavaScript.<br>Как и многие другие текстовые форматы, JSON легко<br>читается людьми. Формат JSON был разработан<br>Дугласом Крокфордом.')" onmouseout="hide()">JSON</a>-шрифтов, поставляемых в составе самого THREE.js.

<h4>Примеры</h4>
<a href="https://threejs.org/examples/#webgl_geometry_text" target="_blank"> WebGL / geometry / text</a><br>
<a href="https://threejs.org/examples/#canvas_geometry_text" target="_blank">canvas / geometry / text</a><br>
<a href="https://threejs.org/examples/#webgl_shadowmap" target="_blank"> WebGL / shadowmap</a><br><br>
Если шрифт не работает или нужно использовать шрифт, которого здесь нет, существует <a href="http://www.jaanga.com/2012/03/blender-to-threejs-create-3d-text-with.html" target="_blank">руководство со скриптом на языке Python</a> для
<a href="https://www.blender.org/" target="_blank" onmouseover="show('свободный, профессиональный пакет для создания<br>трёхмерной компьютерной графики, включающий в себя<br>средства моделирования, анимации, рендеринга,<br>постобработки и монтажа видео со звуком')" onmouseout="hide()">Blender'а</a>, который позволяет экспортировать текст в понятном для Three.js формате JSON.<br><br>


<h2 id="8">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Загрузка трехмерных моделей</h2>
3D-модели доступны в сотнях форматов файлов, каждый из которых имеет разное назначение, разнообразные функции и различную сложность.
Хотя <em>three.js</em> <a href="https://github.com/mrdoob/three.js/tree/dev/examples/js/loaders" target="_blank">предоставляет множество загрузчиков</a>, выбор правильного формата и рабочего процесса позволит сохранить время и избежать разочарования в дальнейшем.
С некоторыми форматами сложно работать из-за неэффективной работы в реальном времени или  из-за того, что нет полной поддержки в настоящее время.<br>
Данное руководство предоставляет рекомендуемый рабочий процесс, подходящий большинству пользователей, и предложения о том, что нужно делать, если все идет не так, как ожидалось.<br><br>

<h3>Прежде чем начать</h3>
Если вы плохо знакомы с управлением локального сервера, для начала ознакомьтесь со статьей <a href="#5">&#171;Как все это запустить локально&#187;</a>. Большинство распространенных ошибок, связанных с просмотром 3D-моделей, можно избежать правильным размещением файлов.<br><br>

<h3>Рекомендуемый рабочий процесс</h3>
Там, где это возможно, рекомендуется использовать формат glTF (GL Transmission Format).
Поддерживаются оба варианта формата и GLB, и GLTF. Поскольку этот формат ориентирован на доставку ресурса во время выполнения кода, он компактен для передачи и быстр для загрузки.
Возможности формата включают в себя сетки (mesh), материалы, текстуры, скины (skin), скелеты (skeleton), цели морфинга (morph target), анимации, виды освещения и камеры.<br>
Общедоступные glTF-файлы имеются на таких сайтах, как <a href="https://sketchfab.com/models?features=downloadable&sort_by=-likeCount&type=models" target="_blank">Sketchfab</a>, или в различных инструментах включен экспорт glTF:
<ul><li><a href="https://github.com/KhronosGroup/glTF-Blender-Exporter" target="_blank">glTF-Blender-Exporter</a> от Khronos Group</li>
<li><a href="https://github.com/KhronosGroup/COLLADA2GLTF" target="_blank">COLLADA2GLTF</a> от Khronos Group</li>
<li><a href="https://github.com/facebookincubator/FBX2glTF" target="_blank">FBX2GLTF</a> от Facebook</li>
<li><a href="https://github.com/AnalyticalGraphicsInc/obj2gltf" target="_blank">OBJ2GLTF</a> от Analytical Graphics Inc</li>
<li><a href="https://www.allegorithmic.com/products/substance-painter" target="_blank">Substance Painter</a> от Allegorithmic</li>
<li><a href="https://www.foundry.com/products/modo" target="_blank">Modo</a> от Foundry</li>
<li><a href="https://www.marmoset.co/toolbag/" target="_blank">Toolbag</a> от Marmoset</li>
<li>и <a href="https://github.com/khronosgroup/gltf#gltf-tools" target="_blank">многое другое</a> ...</li></ul>
Если предпочитаемые инструменты не поддерживают glTF, можно запросить экспорт glTF у авторов или опубликовать его в потоке дорожной карты glTF.
If your preferred tools do not support glTF, consider requesting glTF export from the authors, or posting on the glTF roadmap thread.<br>
Когда glTF - это не вариант, популярные форматы, такие как FBX, OBJ или COLLADA, также доступны и правильно поддерживаются.<br><br>

<h3>Поиск и устранение неисправностей</h3>
Затратив часы на моделирование своего рукотворного шедевра, запускаете его загрузку на веб-страницу и бац, - не работает! Он искажен, обесцвечен или вообще отсутствует. Начните поиск и устранение неисправностей со следующих шагов:
<ol><li>Проверьте консоль JavaScript на ошибки и убедитесь, что используется функция обратного вызова на событие <tt class=lnk onmouseover="show('on error - на ошибку')" onmouseout="hide()">onError</tt>
при вызове метода <tt class=lnk onmouseover="show('load - загрузка')" onmouseout="hide()">load</tt> для записи результата.</li>
<li>Посмотрите модель в другом приложении. Для glTF, программы просмотра с перетаскиванием доступны на three.js и babylon.js.
Если модель правильно представляется в одном или более приложении, считайте что ошибка в <em>three.js</em>.
Если модель не отображается ни в одном из приложений, настоятельно рекомендуется увязать ошибку с приложением, которое использовалось для создания данной модели.</li>
<li>Попробуйте масштабировать модель, уменьшив или увеличив её в 1000 раз. Множество моделей масштабируются по-разному, и крупные модели могут не отображаться, если камера окажется внутри модели.</li>
<li>Присмотритесь нет ли неудачных запросов текстуры в сетевых закладках, вроде <tt>C:\\Path\To\Model\texture.jpg</tt>.
Вместо них используйте пути относительно своей модели, такие как <tt>images/texture.jpg</tt> - при этом может понадобиться изменение файла модели в текстовом редакторе.</li></ol>

<h3>Обратитесь за помощью</h3>
Если процесс поиска неисправностей, указанный выше, пройден, а модель так и не работает, правильно будет обратиться за помощью, что ускорит решение проблемы.
Задайте вопрос на форуме <em>three.js</em> и, если возможно, включите свою модель (или какую-либо более простую модель с той же самой проблемой) в любом доступном формате.
Включите достаточно сведений для того, чтобы кто-то другой быстро воспроизвел проблему - в идеале, демонстрационный пример &#171;вживую&#187;.<br><br>


<h2 id="9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Руководство по миграции и стилю кода</h2>
Руководство <span class="lnk" onmouseover="show('то есть, по переводу программ three.js, сделанных<br>в одной версии, для работы в другой версии three.js')" onmouseout="hide()">по миграции</span> хранится на <a href="https://github.com/mrdoob/three.js/wiki" target="_blank">wiki</a>.
Оно содержит список изменений каждой версии three.js, начиная с релиза r45.<br>
Его можно найти <a href="https://github.com/mrdoob/three.js/wiki/Migration-Guide" target="_blank">здесь</a>.<br>
<div class=note_trans><b>Примечание переводчика:</b> Вики (англ. wiki) — веб-сайт, <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>содержимое которого пользователи могут самостоятельно изменять с помощью инструментов, предоставляемых самим сайтом. Форматирование текста и вставка различных объектов в текст производится с использованием <a href='https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%82%D0%BA%D0%B0' target='_blank'>вики-разметки</a>.<br><br>
Впервые термин «вики» для описания веб-сайта был использован в 1995 году Уордом Каннингемом, разработчиком первой вики-системы WikiWikiWeb, «Портлендского хранилища образцов» программного кода, созданной 25 марта 1995 года, который заимствовал слово гавайского языка, означающее «быстрый».<br><br>
Уорд Каннингем (Ward Cunningham) и его соавтор Бо Леуф (Bo Leuf) в их книге The Wiki Way: Quick Collaboration on the Web (Вики-путь: Живое сотрудничество в сети) описали сущность концепции вики следующим образом:
<ul><li>Вики предлагает всем пользователям редактировать любую страницу или создавать новые страницы на вики-сайте, используя обычный веб-браузер без каких-либо его расширений.</li>
<li>Вики поддерживает связи между разными страницами за счёт почти интуитивно понятного создания ссылок на другие страницы и отображения того, существуют данные страницы или нет.</li>
<li>Вики не является тщательно изготовленным сайтом для случайных посетителей. Напротив, Вики стремится привлечь посетителей к непрерывному процессу создания и сотрудничества, который постоянно меняет вид сайта.</li></ul>
Вики характеризуется такими признаками:
<ul><li>Возможность многократно править текст посредством самой вики-среды (сайта), без применения особых приспособлений на стороне редактора.
<div class=list>Особый язык разметки — так называемая вики-разметка, которая позволяет легко и быстро размечать в тексте структурные элементы и гиперссылки; форматировать и оформлять отдельные элементы.</div>
<div class=list>Учёт изменений (версий) страниц: возможность сравнения редакций и восстановления ранних.</div></li>
<li>Проявление изменений сразу после их внесения.</li>
<li>Разделение содержимого на именованные страницы.
<div class=list>Гипертекст: связь страниц и подразделов сайта через контекстные гиперссылки.</div></li>
<li>Множество авторов. Некоторые вики могут править все посетители сайта.</li></ul><br>
<span style='float:right; margin-top:-16px; background-color:#ffffe8;'><em>(из <a href='https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8' target='_blank'>Википедии</a>)</em>&nbsp;&nbsp;&nbsp;</span></div></div><br>
Весь код и примеры на three.js написаны в стиле кода от <span class=lnk onmouseover="show('Ricardo Cabello - автор <em>three.js</em>')" onmouseout="hide()">Mr.doob</span>. Конечно, можно использовать любой, предпочитаемый вами для работы, стиль, но при добавлении кода в библиотеку или в примеры, требуется следовать этому руководству.
Подробности можно найти <a href="https://github.com/mrdoob/three.js/wiki/Mr.doob%27s-Code-Style%E2%84%A2" target="_blank">здесь</a>.<br><br>

<h2 id="10">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ЧАсто задаваемые ВОпросы</h2>
<h3>Какой формат импорта/экспорта лучше всего поддерживается?</h3>
Рекомендуемым форматом для импорта и экспорта ресурсов является glTF (GL Transmission Format). Потому как этот формат ориентирован на доставку ресурса во время выполнения кода, он компактен для передачи и быстр для загрузки.<br>
Библиотека <em>three.js</em> также предоставляет загрузчики для множества других, популярных форматов, вроде FBX, Collada или OBJ.
Тем не менее, следует в проектах всегда вначале попытаться установить рабочий процесс на основе формата glTF. Более подробную информацию смотрите в описании <a href="#8">загрузки 3D моделей</a>.
<br><br>

<h3>Почему в примерах присутствуют теги meta для окна просмотра (viewport)?</h3>
<pre>&lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;</pre>
Эти тэги управляют размерами окна просмотра (viewport) и масштабом для браузеров мобильных телефонов (где содержимое страницы может отображаться в другом размере, чем видимое окно просмотра).<br>
<a href="http://developer.apple.com/library/safari/#documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html" target="_blank">http://developer.apple.com/library/safari/#documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html</a><br><br>
<a href="https://developer.mozilla.org/en/Mobile/Viewport_meta_tag" target="_blank">https://developer.mozilla.org/en/Mobile/Viewport_meta_tag (англ.)</a><br>
<a href="https://developer.mozilla.org/ru/docs/Mozilla/Mobile/Viewport_meta_tag" target="_blank">https://developer.mozilla.org/ru/docs/Mozilla/Mobile/Viewport_meta_tag на русском</a>

<h3>Как можно сохранить масштаб сцены при изменении размера?</h3>
Хочется чтобы все объекты, независимо от их расстояния до камеры, выглядели одинаково, даже при изменении размера окна.
Ключевое уравнение для решения этой задачи - это формула для видимой высоты (visible_height) на заданном расстоянии от камеры (distance_from_camera):
<pre>visible_height = 2 * Math.tan( ( Math.PI / 180 ) * camera.fov / 2 ) * distance_from_camera;</pre>
Если увеличивается высота окна на определенный процент, то и видимая высота на всех расстояниях также увеличивалась на тот же самый процент.
Этого нельзя сделать изменением положения камеры. Вместо этого следует изменять поле просмотра камеры (параметр fov - field-of-view).
<a href="http://jsfiddle.net/Q4Jpu/" target="_blank">Пример</a>.

<h3>Почему часть моего объекта невидима?</h3>
Это может происходить из-за выбора грани. У граней имеется ориентир, который определяет какая сторона является передней и видимой, а какая - задней и невидимой.
И в обычных условиях при выборе удаляется задняя, невидимая сторона. Если проблема в этом, измените сторону материала на THREE.DoubleSide.
<pre>material.side = THREE.DoubleSide</pre>

<h2 id="11">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ссылки на полезные ресурсы</h2>
Ниже приведена коллекция ссылок, которые возможно будут полезными при изучении three.js.<br>
Если вы нашли что-либо, что хочется сюда добавить, или считаете, что одна из приведенных ссылок больше не уместна или не работает, не стесняйтесь кликнуть кнопку 'edit' (редактировать) справа вверху и внести некоторые изменения!<br><br>
Отметьте также, что <em>three.js</em> довольно быстро развивается, многие из этих ссылок будут содержать устаревшие сведения - если что-то работает не так, как ожидалось или как указывается в этой ссылке,
проверьте консоль браузера на наличие предупреждений и ошибок, соответствующие разделы этой справки и особенно страницу <a href="deprecated-list.htm">DeprecatedList</a> (список устаревших элементов API).<br><br>
В дополнение к этой странице, mrdoob поддерживает коллекцию ссылок, связанных с three.js в Google+. Посмотри их <a href="https://plus.google.com/+ThreejsOrg" target="_blank">здесь</a>.

<h3>Справочные форумы</h3>
Three.js официально использует <a href="http://stackoverflow.com/tags/three.js/info" target="_blank">Stack Overflow</a> для запросов справочной информации.<br>
Если в чем-либо требуется помощь, обращайтесь туда. НЕ НУЖНО создавать проблемы просьбами помочь на Github'е.

<h3>Учебники и курсы</h3>
<h4>Начало работы с three.js</h4>
<ul><li><a href="https://codepen.io/rachsmith/post/beginning-with-3d-webgl-pt-1-the-scene" target="_blank">Beginning with 3D WebGL</a> от <a href="https://codepen.io/rachsmith/" target="_blank">Rachel Smith</a>.</li>
<li><a href="https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/" target="_blank">Animating scenes with WebGL and three.js</a> анимация сцен с WebGL и three.js</li></ul>

<h4>Более расширенные и дополняющие статьи и курсы</h4>
<ul><li><a href="http://blog.cjgammon.com/" target="_blank">Collection of tutorials</a> набор учебников от <a href="http://www.cjgammon.com/" target="_blank">CJ Gammon</a>.</li>
<li><a href="https://medium.com/@soffritti.pierfrancesco/glossy-spheres-in-three-js-bfd2785d4857" target="_blank">Glossy spheres in three.js</a> блестящие сферы в three.js.</li>
<li><a href="https://www.udacity.com/course/cs291" target="_blank">Interactive 3D Graphics</a> - бесплатный курс по Udacity, обучающий основам 3D графики и использующий в качестве инструмента кодирования three.js.</li>
<li><a href="https://aerotwist.com/tutorials/" target="_blank">Aerotwist</a> учебники от <a href="https://github.com/paullewis/" target="_blank">Paul Lewis</a>.</li>
<li><a href="http://learningthreejs.com/" target="_blank">Learning Three.js</a> – a blog with articles dedicated to teaching three.js</li>
<li><a href="http://bkcore.com/blog/3d/webgl-three-js-animated-selective-glow.html" target="_blank">Animated selective glow in Three.js</a> от <a href="https://github.com/BKcore" target="_blank">BKcore</a></li></ul>

<h4>Учебники на других языках</h4>
<ul><li><a href="http://www.natural-science.or.jp/article/20120220155529.php" target="_blank">Building A Physics Simulation Environment</a> построение среды моделирования физических процессов - учебник three.js на японском</li></ul>

<h3>Дополнительная документация</h3>
<ul><li><a href="http://ushiroad.com/3j/" target="_blank">Three.js walking map</a> - a graphical breakdown of the structure of a three.js scene.</li></ul>

<h3>Новости и обновления</h3>
<ul><li><a href="http://www.reddit.com/r/threejs/" target="_blank">Three.js на reddit</a></li>
<li><a href="http://www.reddit.com/r/webgl/" target="_blank">WebGL на reddit</a></li>
<li><a href="http://learningwebgl.com/blog/" target="_blank">Learning WebGL Blog</a> – Авторитетный источник новостей о WebGL.</li>
<li><a href="https://plus.google.com/104300307601542851567/posts" target="_blank">Three.js posts</a> на Google+ – частые сообщения о Three.js</li></ul>

<h3>Примеры</h3>
<ul><li><a href="http://stemkoski.github.io/Three.js/index.html" target="_blank">Professor Stemkoskis Examples</a> (Примеры профессора Стемкоскис) - Сборник дружественных примеров для начинающих, построенных с использованием three.js версии r60a.</li>
<li><a href="https://threejs.org/examples/" target="_blank">Официальные примеры three.js</a> - эти примеры сохраняются как часть репозитория three.js и всегда используют последнюю версию three.js.</li>
<li><a href="https://rawgit.com/mrdoob/three.js/dev/examples/" target="_blank">Official three.js dev branch examples</a>  -
Same as the above, except these use the dev branch of three.js,	and are used to check that everything is working as three.js being is developed.</li></ul>

<h3>Инструменты</h3>
<ul><li><a href="http://www.physgl.org/" target="_blank">physgl.org</a> - javascript front-end with wrappers to three.js, чтобы донести графику WebGL до студентов, изучающих физику и математику. to bring WebGL graphics to students learning physics and math.</li>
<li>[link:http://whitestormjs.xyz/ Whitestorm.js] – A wrapper around Three.js and custom [link:https://github.com/chandlerprall/Physijs physi.js].</li>
<li><a href="http://zz85.github.io/zz85-bookmarklets/threelabs.html" target="_blank">Three.js Inspector</a></li>
<li><a href="http://idflood.github.io/ThreeNodes.js/" target="_blank">ThreeNodes.js</a>.</li></ul>

<h3>Старые ссылки</h3>
Эти ссылки хранятся в исторических целях - в них тоже можно найти что-то полезное, но имейте ввиду, содержащаяся в них информация относится к очень старым версиям three.js.
<ul><li><a href="https://www.youtube.com/watch?v=Dir4KO9RdhM">AlterQualia at WebGL Camp 3</a></li>
<li><a href="http://yomotsu.github.io/threejs-examples/" target="_blank"> Yomotsus Examples</a> (примеры) - коллекция примеров, с использованием three.js версии r45.</li>
<li><a href="http://fhtr.org/BasicsOfThreeJS/#1" target="_blank">Introduction to Three.js</a> - введение в Three.js от <a href="http://github.com/kig/" target="_blank">Ilmari Heikkinen</a> (слайдшоу).</li>
<li><a href="http://www.slideshare.net/yomotsu/webgl-and-threejs" target="_blank">WebGL and Three.js</a> от <a href="http://github.com/yomotsu" target="_blank">Akihiro Oyamada</a> (слайдшоу).</li>
<li><a href="http://bkcore.com/blog/general/adobe-user-group-nl-talk-video-hexgl.html" target="_blank">Fast HTML5 game development using three.js</a> от <a href="https://github.com/BKcore" target="_blank">BKcore</a> (видео).</li>
<li><a href="http://www.youtube.com/watch?v=VdQnOaolrPA">Trigger Rally</a>  от <a href="https://github.com/jareiko" target="_blank">jareiko</a> (видео).</li>
<li><a href="http://blackjk3.github.io/threefab/" target="_blank">ThreeFab</a> - редактор сцен, поддерживался приблизительно до three.js версии r50.</li>
<li><a href="http://bkcore.com/blog/3d/webgl-three-js-workflow-tips.html" target="_blank">Max to Three.js workflow tips and tricks</a> от <a href="https://github.com/BKcore" target="_blank">BKcore</a></li>
<li><a href="http://12devsofxmas.co.uk/2012/01/webgl-and-three-js/" target="_blank">A whirlwind look at Three.js</a> (Беглый взгляд на Three.js) от <a href="http://github.com/nrocy" target="_blank">Paul King</a></li></ul>

<br><br>
</body></html>
