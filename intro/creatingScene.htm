<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Three.js</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../1.css">
<script type="text/javascript" src="../1.js"></script>
</head>
<body>

<h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Создание сцены</h1>
Цель этого раздела - дать краткое вступление в <em>three.js</em>. Начнем его созданием сюжета с вращающимся кубом. На случай если вы запутаетесь и понадобится помощь, рабочий пример кода приводится <a href="#result" onclick="openSpoiler1('code')">внизу страницы</a>.
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Прежде чем начать</h3>
Перед использованием <em>three.js</em>, нужно определиться, где мы будем его показывать. Сохраните следующий HTML-код как файл на своем компьютере вместе с копией файла <tt><a href="http://threejs.org/build/three.js" target="_blank">three.js</a></tt> в папке <tt>js/</tt> и откройте его в своем браузере.
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;My first three.js app&lt;/title&gt;
    &lt;style&gt;
      body { margin: 0; }
      canvas { display: block; }
      &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="js/three.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      // Our Javascript will go here. (Здесь будет Javascript код.)
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
Это все. Весь код ниже идет в пустой тег <tt>&lt;script&gt;</tt>.

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Создание сцены</h3>
Для того, чтобы была возможность что-либо отображать с <em>three.js</em>, нужны три вещи: сцена (scene), камера (camera) и визуализатор (renderer) - также называемый рендерер (по звучанию английского слова), чтобы была возможность показывать сцену, снятую камерой.
<pre>var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );<br>
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );</pre>
Давайте воспользуемся моментом и поясним, что здесь происходит. На данном этапе у нас имеется набор из сцены (переменная <tt>scene</tt>), камеры (переменная <tt>camera</tt>) и визуализатора (переменная <tt>renderer</tt>).<br><br>
В <em>three.js</em> имеется несколько разных камер. Сейчас мы будем использовать <tt>PerspectiveCamera</tt> (т.е. камеру с отображением перспективы).<br><br>
Первым параметром у нее является
<tt class="lnk" onmouseover="show('сокращение от англ. слов field of view - поле зрения или просмотра - угол,<br>которым ограничена зона видимости камеры, объекты не попадающие<br>'
+'в нее не будут видны.<br>Различают поле зрения по горизонтали и по вертикали.<br>В three.js угол fov - это поле зрения по вертикали и измеряется в градусах.')" onmouseout="hide()">fov</tt> (поле зрения или просмотра). Параметр <code>fov</code> - это пространство сцены, видимое на экране в любой момент. Его значение дается в градусах.<br><br>
Второй параметр - это <tt class="lnk" onmouseover="show('сокращение от англ. слов<br>aspect ratio - отношение сторон')" onmouseout="hide()">aspect</tt> (соотношение сторон, пропорции или формат кадра).
Почти всегда нужно использовать отношение ширины элемента к его высоте или рискуете получить такой результат, как при просмотре старых фильмов на широкоэкранных телевизорах, изображение будет выглядеть сплющенным.<br><br>
Следующими двумя параметрами являются <tt class="lnk" onmouseover="show('от англ. слова near - возле, близко')" onmouseout="hide()">near</tt> (ближняя)
и <tt class="lnk" onmouseover="show('от англ. слова far - далеко')" onmouseout="hide()">far</tt> (дальняя) плоскости отсечения.
Это значит, что объекты дальше, чем значение <code>far</code> или ближе, чем <code>near</code> не будут показаны.
Пока о  них можно не беспокоиться, но для увеличения быстродействия в своем приложении можно использовать другие значения.
<div class=note_trans><b>Примечание переводчика:</b> как говорится "вместо тысячи слов", вот на рисунке показаны все параметры камеры. <span class='link' onclick='javascript:spoiler(this)'>... читать далее</span>
<div style='display:none;'>
<img src="../img/1.png" width="600"><br>
Как видите, для камеры задается поле просмотра или поле видимости камеры (параметр <tt>field of view</tt>) в градусах и трехмерное пространство - соотношение ширины и высоты (в параметре <tt>aspect ratio</tt>) и глубина (в параметрах <tt>near</tt> и <tt>far</tt>).</div></div>
Далее идет <span class="lnk" onmouseover="show('Здесь имеет смысл объяснить, что такое рендеринг (rendering),<br>рендер(render) и рендерер (renderer).<br>Рендеринг или по-русски &#171;визуализация&#187; это процесс пересчета<br>трехмерной сцены, т.е. всех объектов, находящихся в поле видимости<br>камеры, в двумерное изображение. Вот это итоговое изображение,<br>отображаемое на экране монитора, называется рендером.<br>А программа, которая выполняет рендеринг, соответственно,<br>называется рендерером или визуализатором.')" onmouseout="hide()">визуализатор (рендерер)</span>. Вот тут то и происходит волшебство.
В дополнение к используемому здесь <span class="lnk" onmouseover="show('Это рендерер, созданный на основе WebGL (Web-based Graphics Library) —<br>кроссплатформенный API для 3D-графики в браузере, разрабатываемый<br>некоммерческой организацией Khronos Group.<br>API построена на основе OpenGL ES 2.0 и даёт возможность реализации<br>3D-графики в браузере, использует HTML5-элемент canvas, также<br>оперирует с DOM. Автоматическое управление памятью предоставляется<br>языком JavaScript.')" onmouseout="hide()">WebGLRenderer'у</span>,
в <em>three.js</em> имеется несколько других, зачастую используемых в качестве резервного варианта для пользователей со старыми браузерами или тех, у кого нет поддержки WebGL по другим причинам.<br><br>
Помимо создания экземпляра визуализатора (рендерера), также нужно установить размеры в которых будет отображаться наше приложение.
Хорошей идеей будет использование ширины и высоты области, которую нам хочется занять нашим приложением - в данном случае, это ширина и высота окна браузера.
При выполнении ресурсоёмких приложений также можно задать параметру <tt>setSize</tt> меньшие значения, вроде <tt>window.innerWidth/2</tt> и <tt>window.innerHeight/2</tt>, которые сделают визуализацию приложения в половинном размере.<br><br>
Если нужно сохранить размеры приложения, но отобразить его с более низким разрешением, можно сделать это, вызвав параметр <tt>setSize</tt> со значением <tt>false</tt> в качестве параметра <tt>updateStyle</tt>.<br>
Например, код <tt>setSize(window.innerWidth/2,&nbsp;window.innerHeight/2,&nbsp;false)</tt> сделает визуализацию приложения в половинном разрешении, с учетом того, что наш <tt>&lt;canvas&gt;</tt> имеет <tt>100%</tt>'ую ширину и высоту от размеров окна браузера.<br><br>
И наконец, что не менее важно, к нашему HTML-документу добавляем элемент визуализатора. Это элемент <tt>&lt;canvas&gt;</tt>, на котором рендерер и отображает сцену.<br><br>
<em>Так то все хорошо, но где этот обещанный куб?</em><br>Сейчас мы его добавим.<br><br>
<pre>var geometry = new THREE.BoxGeometry();
var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );<br>
camera.position.z = 5;</pre>
Для создания куба нам потребуется <b>BoxGeometry</b>, т.е. геометрия куба.
Это объект, содержащий все точки (вершины - <b>vertices</b> ед. число vertex) и стороны (грани - <b>faces</b>) куба. В дальнейшем мы рассмотрим это более подробно.
<div class=note_trans><b>Примечание переводчика:</b> Здесь и далее слово &#171;геометрия&#187; означает совокупность всех геометрических свойств объекта,
т.е. все элементы, которые составляют каркас объекта - вершины, грани, а также их цвет и расположение. <span class='link' onclick='javascript:spoiler(this)'>... читать далее</span>
<div style='display:none;'>Кроме того, слово грани (в английском варианте это faces, или face в единственном числе) в данной справке имеет двойной смысл: грань - в смысле сторона трехмерной геометрической фигуры и грань - ячейка-треугольник каркаса объекта.<br>
<img src="../img/BoxGeometry1.png" width="300"><br>
Получается что грань объекта-куба состоит из треугольных граней ячеек каркаса.<br>
Далее в справке гранью будет называться именно ячейка каркаса, в случае грани, как стороны объекта, будет дополнительное описание, например грань куба.</div></div>
В дополнение к геометрии куба понадобится и материал для его окрашивания. В <em>three.js</em> имеется несколько материалов, но в данном случае будем использовать <tt>MeshBasicMaterial</tt>.
Все материалы принимают свойства объекта, что были к нему применены. Чтобы сохранить простоту вещей, предоставим только атрибут цвета&nbsp;<tt>0x00ff00</tt>, т.е. зеленый цвет. Это работает точно также как в CSS или Photoshop (шестнадцатиричные значения цвета).<br><br>
Третья вещь, что нам потребуется, это <tt>Mesh</tt>, т.е. сетка. <tt>Mesh</tt> представляет собой объект, который принимает геометрию и применяет к ней материал, который потом можно вставить в нашу сцену и свободно перемещаться вокруг.<br><br>
По умолчанию, при вызове <tt>scene.add()</tt>, добавляемая нами вещь будет располагаться в координатах&nbsp;<tt>(0,0,0)</tt>. Чтобы уйти от этого, в последней строке просто немножко смещаем камеру.

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Визуализация (рендеринг) сцены</h3>
Если скопировать код, приведенный выше, и вставить в заранее созданный HTML-файл, то вы ничего не увидите. Потому что на самом деле пока еще нечего отображать. Для того, чтобы что-нибудь появилось нужно вызвать <tt>render</tt> или цикл анимации.
<pre>function animate() {
	requestAnimationFrame( animate );
	renderer.render( scene, camera );
}
animate();</pre>
Этот код создаст цикл, который каждый раз при обновлении экрана будет вызывать визуализатор для прорисовки сцены (обычно это 60 раз в секунду). Если вы новичок в написании браузерных игр, то можете сказать:
"Почему бы нам просто не вызвать JavaScript-функцию <tt class="lnk" onmouseover="show('set interval - установка интервала,<br>т.е. времени между вызовами функции перерисовки сцены')" onmouseout="hide()">setInterval</tt>?"
Конечно же, можно это сделать, но у функции <tt class="lnk" onmouseover="show('request animation frame - запрос кадра анимации<br>- позволяет синхронизировать все анимации со<br>встроенными механизмами обновления страницы.<br><br>То есть, сгруппированы будут не только JavaScript-анимации,<br>но и CSS-анимации и другие браузерные перерисовки. При этом<br>графический ускоритель используется максимально эффективно<br>и исключается повторная обработка одних и тех же участков<br>страницы.<br>А значит – меньше будет загрузка CPU, да и сама анимация<br>станет более плавной.')" onmouseout="hide()">requestAnimationFrame</tt> имеется несколько преимуществ.
Пожалуй, самым важным из них является то, что анимация приостанавливается при переходе пользователя на другую вкладку браузера, а следовательно не тратится драгоценная вычислительная мощность и заряд аккумулятора.<br><br>
<div class=note_trans><b>Примечание переводчика:</b> Вот ещё одна картинка для лучшего понимания процесса визуализации в three.js. <span class='link' onclick='javascript:spoiler(this)'>... читать далее</span>
<div style='display:none;'>
<img src="../img/2.png" width="400" align="right"><br>
Это так называемый <span class="lnk" onmouseover="show('Граф — абстрактный математический объект, представляющий из себя<br>множество вершин графа и набор рёбер, то есть соединений между парами вершин.<br>Для разных областей применения виды графов могут различаться направленностью,<br>ограничениями на количество связей и дополнительными данными о вершинах<br>или рёбрах.<br>Многие структуры, представляющие практический интерес в математике<br>и информатике, могут быть представлены графами.')" onmouseout="hide()">граф</span>,
т.е. в нашем случае - совокупность всех объектов, участвующих в визуализации, и связи между ними.<br><br>

Геометрические параметры объекта (т.е. каркас) или попросту "геометрия" - Geometry, составленная из Vertex (вершин) и Face3 (граней-треугольников), передаётся в Mesh (сетку).<br>
Сюда же поступает и Material (материал), который создается после преобразования изображения (Image) в текстуру (Texture).
<br><br>
Грубо говоря, каркас (Geometry) "обтягивается" материалом (Material) при помощи сетки (Mesh). Причем сетка уже является элементом сцены, то есть, её то мы и будем видеть на объекте.<br><br>
Кроме сетки, на сцене находятся освещение и камера. Ну с освещением все понятно, его функция освещать сцену и объекты на ней, а вот с камерой несколько сложнее. Ей задаются параметры, с которыми она должна смотреть на сцену, и передаются в визуализатор или рендерер (renderer). Камеру можно перемещать.<br><br>
Также в рендерер передается и сцена со всеми объектами, находящимися на ней, т.е. вид (или представление, визуализация - render). В этом представлении на сцене, если требуется, можно задать перемещение объектов или всей сцены, т.е. их анимацию.<br><br>
Рендерер показывает нам на &lt;canvas&gt; получившуюся картинку, то есть освещенную сцену с объектами на ней с точки зрения камеры.<br><br>
<span style='float:right; margin-top:-16px; background-color:#ffffe8;'><em>(картинка <a href='http://davidscottlyons.com/threejs/presentations/frontporch14/index.html#slide-16' target='_blank'>отсюда</a>)</em>&nbsp;&nbsp;&nbsp;</span><br></div></div>

<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Анимация куба</h3>
Если весь код, приведенный выше, вставлен в заранее созданный файл, вы должны увидеть зеленый куб. Давайте сделаем его чуть поинтереснее - покрутим его.<br>
<img src="../img/cube.gif" width="250" align="right"><br>
Добавьте следующий код сразу перед вызовом <b>renderer.render</b> функции <b>render</b>:
<pre>cube.rotation.x += 0.01;
cube.rotation.y += 0.01;</pre>
Этот код будет выполняться в каждом кадре (60 раз в секунду) и задаст кубу хорошую анимацию вращения. В принципе, все что нужно перемещать или изменять во время работы приложения, должно проходить через цикл анимации.
Конечно, там можно вызвать и другие функции, но постарайтесь не делать функцию <b>animate</b> в несколько сотен строк.

<h3 id="result">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Итог</h3>
Поздравляем! Вы только что получили свое первое <em>three.js</em> приложение. Как видите, просто нужно было где-то начать.<br><br>
Полный код показан ниже, а также в виде редактируемого, <a href="https://jsfiddle.net/mkba0ecu/" target="_blank">реально действующего примера на jsfiddle.net</a>.
Чтобы получить более полное представление о его работе,  поиграйтесь с ним (т.е. попробуйте поменять те или иные параметры и понаблюдайте за получающимися изменениями).
<div id="code" class="blockindent"><b>Код:</b> <span class='link' onclick='javascript:spoiler1(this)'>... показать</span>
<div style='display:none;'>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;My first Three.js app&lt;/title&gt;
    &lt;style&gt;
      body { margin: 0; }
      canvas { display: block; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="js/three.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );<br>
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );<br>
      var geometry = new THREE.BoxGeometry();
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      var cube = new THREE.Mesh( geometry, material );
      scene.add( cube );<br>
      camera.position.z = 5;<br>
      var animate = function () {
        requestAnimationFrame( animate );<br>
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;<br>
        renderer.render(scene, camera);
      };<br>
      animate();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><br>

<br><br>
</body></html>