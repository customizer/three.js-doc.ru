<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Three.js</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../1.css">
<script type="text/javascript" src="../1.js"></script>
</head>
<body>

<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Как это все обновлять</h2>
Все объекты по умолчанию автоматически обновляют свои матрицы, если были добавлены на сцену при помощи
<pre>var object = new THREE.Object3D;
scene.add( object );</pre>
или если они являются дочерними по отношению к другому объекту, уже добавленному на сцену:
<pre>var object1 = new THREE.Object3D;
var object2 = new THREE.Object3D;<br>
object1.add( object2 );
scene.add( object1 ); //object1 and object2 will automatically update their matrices
                      //object1 и object2 будут автоматически обновлять свои матрицы</pre>
Впрочем, если известно что объект будет статичным, можно запретить автоматическое обновление и обновлять матрицу трансформации вручную, когда потребуется.
<pre>object.matrixAutoUpdate = false;
object.updateMatrix();</pre><br>

<h3>Геометрические элементы</h3>
<div class=note_trans><b>Примечание переводчика:</b> Здесь рассматривается обновление геометрических параметров объекта, т.е. вершины, грани, их расположение, нормали, цвета и т.д.</div>
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="../core/bufferGeometry.htm">BufferGeometry</a></h3>
Элементы <a href="../core/bufferGeometry.htm" onmouseover="show('BufferGeometry')" onmouseout="hide()">BufferGeometry</a> сохраняют информацию (такую как положение вершин, индексы граней, нормали, цвета, текстурные координаты
(<a href="https://ru.wikipedia.org/wiki/UV-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" onmouseover="show('соответствие между координатами на поверхности трёхмерного объекта (X, Y, Z)<br>и координатами на текстуре (U, V - эти буквы обозначают оси двумерной текстуры,<br>потому что «X», «Y» и «Z» уже используются для обозначения осей 3D-объекта<br>в пространстве модели). Значения U и V обычно изменяются от 0 до 1.');" onmouseout="hide()">UV</a>)
и все атрибуты, установленные пользователем) в <a href="../core/bufferGeometry.htm">буферах</a>, которые являются <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" target="_blank">типизованными массивами</a> (<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Typed_arrays" target="_blank">здесь</a> описание этих массивов на русском языке).
Это делает работу элементов BufferGeometry в общем-то быстрее, по сравнению с обычными элементами <a href="../core/geometry.htm" onmouseover="show('Geometry')" onmouseout="hide()">Geometry</a> за счет того, что с ними сложнее работать.<br><br>
Что касается обновления элементов BufferGeometry, то самое главное для понимания, не стоит изменять размер буферов (это очень затратно, по существу равнозначно созданию новой геометрии). Однако можно обновлять содержимое буферов.<br><br>
Это значит, если известно, что какой-нибудь атрибут элемента BufferGeometry будет расти (например, количество вершин), то следует изначально выделить буфер, достаточно большой, для хранения любого числа новых вершин, которые могут быть созданы.
Конечно, это также означает, что для элемента <tt>BufferGeometry</tt> существует максимальный размер - нет способа создать <tt>BufferGeometry</tt>, которую можно было бы успешно расширять до бесконечности.<br><br>
В качестве примера попробуем нарисовать линию, которая увеличивается во время визуализации. Выделим место в буфере для 500 вершин, но сначала, при помощи метода <tt><a href="../core/bufferGeometry.htm#drawRange">BufferGeometry.drawRange</a></tt>, нарисуем только две.
<pre>var MAX_POINTS = 500;<br>
// geometry  (геометрия)
var geometry = new THREE.BufferGeometry();<br>
// attributes (атрибуты)
var positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point (3 вершины на точку)
geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );<br>
// draw range (рисуем ряд точек)
var drawCount = 2; // draw the first 2 points, only (рисуем только первые две точки)
geometry.setDrawRange( 0, drawCount );<br>
// material (материал)
var material = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 2 } );<br>
// line (линия)
var line = new THREE.Line( geometry,  material );
scene.add( line );</pre>
Далее будем случайным образом добавлять точки к линии при помощи шаблона в виде:
<pre>var positions = line.geometry.attributes.position.array;<br>
var x, y, z, index;
x = y = z = index = 0;<br>
for ( var i = 0, l = MAX_POINTS; i &lt; l; i ++ ) {<br>
  positions[ index ++ ] = x;
  positions[ index ++ ] = y;
  positions[ index ++ ] = z;<br>
  x += ( Math.random() - 0.5 ) * 30;
  y += ( Math.random() - 0.5 ) * 30;
  z += ( Math.random() - 0.5 ) * 30;<br>
}</pre>
Если нужно изменить <em>количество точек</em>, отображаемых после первой визуализации, сделайте следующее:
<pre>line.geometry.setDrawRange( 0, newValue );</pre>
Если, после первой визуализации, нужно изменить значения данных положения, следует установить флаг <tt>needsUpdate</tt>, вот так:
<pre>line.geometry.attributes.position.needsUpdate = true;
  // required after the first render (запрашивается после первой визуализации)</pre>
<a href="http://jsfiddle.net/w67tzfhx/" target="_blank">Вот &#171;пу&#769;танка&#187;</a>, представленная анимированной линией, которую можно приспособить под свои нужды.<br><br>

<h4>Примеры:</h4>
<pre><a href="https://threejs.org/examples/#webgl_custom_attributes" target="_blank">WebGL/custom/attributes</a>
<a href="https://threejs.org/examples/#webgl_buffergeometry_custom_attributes_particles" target="_blank">WebGL/buffergeometry/custom/attributes/particles</a></pre><br>

<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="../core/geometry.htm">Geometry</a></h4>
Следующие флаги управляют обновлением различных атрибутов геометрии. Устанавливайте флаги только для атрибутов, требующих обновления, так как обновления - затратная вещь. После изменения буферов эти флаги автоматически сбрасываются обратно к значению <tt>false</tt>.
Если требуется продолжать обновление буферов, нужно сохранить их как <tt>true</tt>. Обратите внимание, что это относится только к <a href="../core/geometry.htm">Geometry</a>, а не к <a href="../core/bufferGeometry.htm">BufferGeometry</a>.
<pre>var geometry = new THREE.Geometry();
geometry.verticesNeedUpdate = true;
geometry.elementsNeedUpdate = true;
geometry.morphTargetsNeedUpdate = true;
geometry.uvsNeedUpdate = true;
geometry.normalsNeedUpdate = true;
geometry.colorsNeedUpdate = true;
geometry.tangentsNeedUpdate = true;</pre>
Кроме этого, в версиях, предшествующих <a href="https://github.com/mrdoob/three.js/releases/tag/r66" target="_blank">r66</a>, сеткам (mesh) необходимо включать флаг <tt>dynamic</tt> (для сохранения внутренних типизованных массивов):
<pre>// removed after r66 (удаляется после версии r66)
geometry.dynamic = true;</pre><br>
<h4>Пример:</h4>
<pre><a href="https://threejs.org/examples/#webgl_geometry_dynamic" target="_blank">WebGL / geometry / dynamic</a></pre><br>

<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Материалы</h4>
Все значения <span class="lnk" onmouseover="show('В шейдерах существует три типа переменных: униформы (uniforms), атрибуты<br>(attributes) и вариации (varyings):<br>'
+'&nbsp; &nbsp; &nbsp; Униформы (uniforms) - это переменные, что имеют единообразное значение<br>для всех вершин; освещение, туман и карты тени - вот примеры данных, которые<br>будут храниться в униформах. Обращаться к униформам можно как с помощью<br>вершинного шейдера, так и с помощью шейдера фрагментов.<br>'
+'&nbsp; &nbsp; &nbsp; Атрибуты (attributes) - это переменные, связанные с каждой вершиной -<br>например, положение вершины, нормаль к грани и цвет вершины - это все<br>примеры данных, которые будут хранится в атрибутах. Атрибуты могут быть<br>доступны только внутри вершинного шейдера.<br>'
+'&nbsp; &nbsp; &nbsp; Вариации (varyings) - это переменные, которые передаются из вершинного<br>шейдера в шейдер фрагмента. Для каждого фрагмента значение каждой<br>вариации будет плавно интерполироваться из значений смежных вершин.')" onmouseout="hide()">переменных-униформ</span> могут быть свободно изменены (например, цвета, текстуры, непрозрачность и так далее), значения отправляются в шейдер с каждым кадром.
<div class=note_trans><b>Примечание переводчика:</b> В области компьютерной графики, шейдер - это компьютерная программа<a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>используемая для создания оттенков (т.е. для шейдинга, от англ. слова shade - оттенок, тон цвета, тень): производства соответствующих уровней освещенности, затемнения и окрашивания изображения, или, на современном этапе, также для создания спецэффектов и пост-обработки видео.<br><br>
Шейдеры рассчитывают эффекты визуализации с помощью процессора видеокарты, хотя это и не обязательное условие.
Языки программирования шейдеров обычно используются для написания <span class="lnk" onmouseover="show('programmable rendering pipeline – программируемый конвейер<br>рендеринга – конвейер графического процессора (GPU) с<br>изменяемыми (перепрограммируемыми) функциями');" onmouseout="hide()">программируемого конвейера рендеринга</span>
<span class="lnk" onmouseover="show('сокращение от англ. слов graphics processing unit<br>- блок графических вычислений или графический<br>процессор или попросту - процессор видеокарты');" onmouseout="hide()">GPU</span>,
который в основном заменил <span class="lnk" onmouseover="show('fixed-function pipeline – конвейер с фиксированными<br>(постоянными) функциями, не предусматривающий<br>программирования (перепрограммирования)');" onmouseout="hide()">конвейер с фиксированными функциями</span>,
допускающий только общие преобразования геометрии и функции закрашивания пикселей; с использованием шейдеров могут быть применены и настраиваемые эффекты.
Положение, оттенок, насыщенность, яркость и контрастность всех пикселей вершин или текстур, используемых для построения окончательного изображения могут быть изменены "на лету", с использованием алгоритмов, определенных в шейдере, а также могут быть изменены при помощи внешних переменных и текстур, вводимых программой, вызывающей шейдер.
<br><br>
<span style='float:right; margin-top:-16px; background-color:#ffffe8;'><em>(из <a href='https://en.wikipedia.org/wiki/Shader' target='_blank'>Википедии</a>, перевод мой)</em>&nbsp;&nbsp;&nbsp;</span></div></div><br>
Параметры связанные с GLstate также могут быть изменены в любой момент (<tt>depthTest</tt>, <tt>blending</tt>, <tt>polygonOffset</tt>, и т.д.).<br><br>
Плоское (flat) / плавное (smooth) затенение <span class="lnk" onmouseover="show('здесь смысл слова &quot;запекается&quot; в том,<br>что статичные данные о затенении<br>фиксируются и сохраняются')" onmouseout="hide()">"запекается"</span> в нормалях. Требуется сброс буфера нормалей (смотрите выше).<br><br>
Следующие свойства нельзя просто так изменить во время выполнения (после того, как материал был визуализирован хотя бы раз):
<ul><li>типы и число униформ</li>
<li>типы и число источников освещения</li>
<li>наличие или отсутствие
<ul><li>текстуры (texture)</li>
<li>тумана (fog)</li>
<li>цвета вершин (vertex colors)</li>
<li><span class="lnk" onmouseover="show('Скининг (от английского слова skin - кожа, skinning - процесс<br>создания кожи, встречается также написание скиннинг)<br>- это один из этапов постановки 3d-персонажа, когда модель<br>персонажа привязывается (скинится) к скелету.<br>'
+'Делается это для того, чтобы при движении скелета двигалась и<br>сама модель персонажа.<br>'
+'Это достаточно трудоемкий процесс, поскольку нужно правильно<br>назначить вес (англ. weight) для каждой вершины модели.<br>Чем больше вес, тем больше влияет конкретная кость<br>на конкретную вершину 3d-модели.');" onmouseout="hide()">скининга</span> (skinning)</li>
<li><span class="lnk" onmouseover="show('Морфинг (англ. morphing, трансформация) — технология в компьютерной<br>анимации, визуальный эффект, создающий впечатление плавной<br>трансформации одного объекта в другой. Встречается в трёхмерной<br>и двухмерной (как растровой, так и векторной) графике.<br>'
+'Для создания эффекта используются как минимум два изображения,<br>на которых художник задаёт в зависимости от использующегося<br>программного обеспечения опорные фигуры или ключевые точки<br>(т. н. маркеры, или метки), которые помогают компьютеру выполнить<br>правильный морфинг, то есть создать изображения промежуточных<br>состояний (интерполируя имеющиеся данные).<br>'
+'Морфинг также часто используется для создания анимации, когда не<br>стоит задача добиться эффекта превращения одного объекта в другой,<br>а требуется лишь выстроить промежуточные состояния между двумя<br>(и более) ключевыми положениями анимируемого объекта.');" onmouseout="hide()">морфинга</span> (morphing)</li>
<li><span class="lnk" onmouseover="show('Теневая карта (англ. shadow map) - способ моделирования теней в<br>трёхмерной компьютерной графике. Этот способ используется при<br>создании как отображаемых, так и анимируемых в реальном<br>времени трехмерных сцен и широко применяется в киноиндустрии<br>и компьютерных играх.<br>'
+'Традиционный способ создания теневых карт основан на<br>использовании Z-буфера (буфера глубины). Сначала происходит<br>построение сцены в Z-буфер с точки зрения источника света,<br>чтобы установить видимые из этой точки пикселы и расстояния до<br>них - таким образом формируется теневая карта, представляющая<br>собой двухмерную текстуру. После этого сцена перестраивается<br>уже с точки зрения наблюдателя со сравнением текстурных<br>координат с теневой картой; если такое сравнение говорит, что<br>соответствующий пиксел невидим с точки зрения источника света<br>и, следовательно, должен быть затенен, он закрашивается<br>темным цветом.');" onmouseout="hide()">теневой карты</span> (shadow map)</li>
<!-- https://en.wikipedia.org/wiki/Shadow_mapping
http://steps3d.narod.ru/tutorials/shadow-map-tutorial.html -->
<li><span class="lnk" onmouseover="show('Значение альфа-канала входит в качестве четвёртой компоненты в<br>вектор цвета в формате RGBA. Альфа-компонент определяет<br>непрозрачность материала в диапазоне от 1.0 означающего полную<br>непрозрачность до 0.0, означающего полную прозрачность.<br>'
+'Для того чтобы создавать прозрачные и полупрозрачные объекты,<br>необходимо разрешить тестировать буфер альфа-канала и включить<br>механизм под названием альфа-смешивание.<br>'
+'При включённом альфа-тесте сравнивается входящее значение<br>альфа-канала с эталонным значением. Фрагмент принимается или<br>отклоняется в зависимости от результатов сравнения.');" onmouseout="hide()">альфа-теста</span> (alpha test)</li>
</ul></li></ul>
<!-- https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B5%D0%BB%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%86%D0%B8%D1%8F - скелетная анимация -->
Изменения в них требуют создания новой шейдерной программы. Нужно будет установить
<pre>material.needsUpdate = true</pre>
Имейте в виду, что это может быть довольно медленно и вызывать подергивание кадров (особенно в Windows, поскольку шейдерная компиляция в DirectX медленнее, чем в OpenGL).<br><br>
Для повышения плавности работы можно в некоторой степени имитировать изменения этих функций, с помощью «фиктивных» значений, таких как освещение с нулевой интенсивностью, белых текстур или тумана с нулевой плотностью.<br><br>
Можно свободно изменять материал, используемый для частей геометрии, однако нельзя изменять способ разделения объекта на части (в соответствии с материалами граней).

<h4>Если во время выполнения нужны разные конфигурации материалов:</h4>
Если число материалов / частей невелико, можно заблаговременно предварительно разделить объект
(например, для человека - волосы (hair) / лицо (face) / тело (body) / верхняя одежда (upper clothes) / брюки (trousers),
для автомобиля - перед (front) / боковые стороны (sides) / верх (top) / стекла (glass) / шины (tire) / салон (interior)).<br><br>
Если число велико (к примеру каждое лицо/грань может быть потенциально различным), рассмотрите другое решение, такое как использование атрибутов/текстур для приведения к другому внешнему виду.
<h4>Примеры:</h4>
<pre><a href="https://threejs.org/examples/#webgl_materials_cars" target="_blank">WebGL / materials / cars</a>
<a href="https://threejs.org/examples/#webgl_postprocessing_dof" target="_blank">WebGL / webgl_postprocessing / dof</a></pre><br>

<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Текстуры</h4>
Если текстуры изображения, элемента canvas, видео и данных были изменены, то у них должен быть установлен следующий флаг:
<pre>texture.needsUpdate = true;</pre>
Обновление целей визуализации произойдет автоматически.
<h4>Примеры:</h4>
<pre><a href="https://threejs.org/examples/webgl_materials_video" target="_blank">WebGL / materials / video</a>
<a href="https://threejs.org/examples/webgl_rtt" target="_blank">WebGL / rtt</a></pre><br>

<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Камеры</h4>
Положение в пространстве и направление съемки камеры обновляются автоматически. Если нужно изменить параметры
<ul><li><tt>fov</tt> (поле просмотра)</li>
<li><tt>aspect</tt> (соотношение сторон)</li>
<li><tt>near</tt> (ближняя плоскость отсечения)</li>
<li><tt>far</tt> (дальняя плоскость отсечения)</li></ul>
то требуется пересчитать матрицу проекции:
<pre>camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();</pre><br><br>

<br><br>
</body>
</html>
