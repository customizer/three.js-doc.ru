<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Three.js</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../1.css">
<script type="text/javascript" src="../1.js"></script>
</head>
<body>

<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Установка</h2>

Установку <em>three.js</em> можно сделать из
<tt><a href="https://ru.wikipedia.org/wiki/Npm" target="_blank" onmouseover="show('<code>npm</code> (сокращ. от англ. слов Node Package Manager - менеджер пакетов <tt>Node.js</tt>)<br>- менеджер пакетов для языка программирования JavaScript, входящий в<br>состав <tt>Node.js</tt>.<br>Он состоит из клиента командной строки (также называемого <tt>npm</tt>) и онлайновой<br>базы данных как общедоступных, так и платных, частных пакетов (называемой<br>реестром <tt>npm</tt>). Доступ к реестру осуществляется через клиента, а доступные<br>пакеты можно искать и просматривать на веб-сайте <tt>npm</tt>.')" onmouseout="hide()">npm</a></tt>
и других современных инструментов сборки, а также сразу начать работу прямо со <span class="lnk" onmouseover="show('Веб-сайт может быть динамическим или статическим. В первом случае при<br>запросе пользователя страница собирается в момент запроса, а<br>затем отображаются в браузере. Во втором — на сервере хранятся<br>уже готовые страницы.<br>Статические сайты состоят из готовых страниц (HTML, JS, графика, шрифты),<br>загруженных на сервер. Важные достоинства статических сайтов: скоростная<br>загрузка страниц и повышенная устойчивость ко взлому. Кроме того, сайты из<br>статических страниц без проблем выдерживают гораздо большую<br>посещаемость, чем их динамические «коллеги».')" onmouseout="hide()">статического сайта</span>, размещенного в Интернете, или
<tt><a href="https://ru.wikipedia.org/wiki/Content_Delivery_Network" target="_blank" onmouseover="show('Сеть доставки (и распространения) содержимого (CDN - сокращ. англ. слов<br>Content Delivery Network или Content Distribution Network) — географически<br>распределённая сетевая инфраструктура, позволяющая оптимизировать доставку<br>и распространение содержимого конечным пользователям в сети Интернет.<br>Использование контент-провайдерами CDN способствует увеличению скорости<br>загрузки интернет-пользователями аудио-, видео-, программного, игрового и<br>других видов цифрового содержимого в точках присутствия сети CDN.')" onmouseout="hide()">CDN</a></tt>.
Для большинства пользователей установка из <tt>npm</tt> является наилучшим выбором.<br><br>

Независимо от выбранного варианта, будьте последовательны и импортируйте все файлы из одной и той же версии библиотеки.
Смешивание файлов от разных источников может привести к двойному включению кода или даже к неожиданному краху приложения.<br><br>

Все способы установки <code>three.js</code> полагаются на модули ES (смотрите <a href="https://eloquentjavascript.net/10_modules.html#h_hF2FmOVxw7" target="_blank">Eloquent JavaScript: ECMAScript Modules</a> (Выразительный JavaScript: Модули ECMAScript),
позволяющие включать только те части библиотеки, которые необходимы в конечном проекте.

<div class=note_trans><b>Примечание переводчика:</b> Выше дана ссылка на третье издание книги "Выразительный JavaScript" от Марейн Хавербек (Marijn Haverbeke). Это довольно интересный и даже увлекательный экземпляр учебной литературы.
Имеется (посредственный по качеству) <a href="https://www.piter.com/product_by_id/142132749?recommended_by=dynamic&recommended_code=46ce9b64036c53acd60bfc7a38ecdaf2" target="_blank">перевод данной книги на русский язык от издательства "Питер"</a>,
а также хороший <a href="https://eloquent-javascript.karmazzin.ru/" target="_blank">перевод второго издания</a> от В.Голованова. Если кто не читал, очень советую почитать.<br>
Перевод же части "Модули ECMAScript" 10 главы "Модули" от третьего издания, на которую ссылаются выше, приводится здесь... <span class='link' onclick='javascript:spoiler(this)'>... читать далее</span>
<div style='display:none;'>
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Модули ECMAScript</h3>
Модули CommonJS работают достаточно хорошо и в сочетании с NPM позволили сообществу JavaScript начать в больших масштабах совместное использование кода.<br><br>
Но они остаются чем-то вроде заматывания скотчем.
Нотация несколько неуклюжа — например, вещи, добавляемые в экспорт, недоступны в локальной области видимости.
А поскольку <tt>require</tt> - это не только строковый литерал, но и обычный вызов функции, принимающий любой тип аргумента, бывает сложно определить зависимости модуля без запуска его кода.<br><br>
Вот поэтому стандарт JavaScript от 2015 года и вводит свою собственную, отличную от других, систему модулей. Обычно их называют модулями ES, где ES обозначает ECMAScript.
Основные понятия зависимостей и интерфейсов остаются прежними, но есть отличия в деталях. Во-первых, нотация теперь интегрирована в язык.
Вместо вызова функции для доступа к зависимости используется специальное ключевое слово <tt>import</tt>.
<pre>import ordinal from "ordinal";
import {days, months} from "date-names";<br>
export function formatDate(date, format) { /* ... */ }</pre>
Аналогично, ключевое слово <tt>export</tt> используется для экспорта вещей. Они могут появляться перед определением функции, класса или привязки (<tt>let</tt>, <tt>const</tt> или <tt>var</tt>).<br><br>
Интерфейс модуля ES - это не одно значение, а набор поименованных привязок. Предшествующий модуль связывает <tt>formatDate</tt> с функцией.
При импорте из другого модуля импортируется не значение, а привязка и поэтому модуль экспорта может изменить значение привязки в любое время и модули, импортирующие его, увидят его новое значение.<br><br>
При наличии привязки с названием <tt>default</tt> она рассматривается как основное экспортируемое значение модуля.
Если вы импортируете модуль (такой как <tt>ordinal</tt> в примере) без скобок вокруг названия привязки, то получите <tt>default</tt> привязку.
Такие модули могут по-прежнему экспортировать другие привязки под разными названиями наряду с их <tt>default</tt> экспортом.<br><br>
Для создания экспорта по умолчанию, напишите <tt>export default</tt> перед объявлением класса, объявлением функции или выражением.
<pre>export default ["Winter", "Spring", "Summer", "Autumn"];</pre>
Возможно переименование импортируемых привязок при помощи слова <tt>as</tt>.
<pre>import {days as dayNames} from "date-names";
console.log(dayNames.length);
// > 7</pre>
Другое важное отличие заключается в том, что импорт модуля ES происходит до запуска скрипта модуля.
Это означает, что объявления <tt>import</tt> могут не появляться внутри функций или блоков, а имена зависимостей должны быть строками в кавычках, а не произвольными выражениями.<br><br>
На момент написания книги, сообщество JavaScript находилось в процессе принятия этого стиля модуля. Но это был медленный процесс.
После того, как формат был определен, браузерам и Node.js потребовалось несколько лет, чтобы начать поддерживать его.
И хотя сейчас они в основном поддерживают его, у этой поддержки все еще есть проблемы и все еще продолжается обсуждение того, как такие модули должны распространяться через NPM.<br><br>
Многие проекты пишутся с использованием модулей ES, а затем при публикации автоматически преобразуются в какой-нибудь другой формат.
Мы находимся в переходном периоде, когда две разные системы модулей используются бок о бок и полезно иметь возможность читать и писать код в любой из них.
</div></div>


<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Установка при помощи <tt>npm</tt></h3>
Для установки <tt>npm</tt>-модуля <tt>three</tt>, откройте окно командной строки в папке проекта и запустите:
<pre>npm install --save three</pre>
Пакет будет загружен и установлен. Теперь нужно импортировать его в свой код:
<pre>///////////////////////////////////////////////////////
// Option 1: Import the entire three.js core library.
// Вариант 1: Импорт основной библиотеки three.js целиком.
import * as THREE from 'three';<br>
const scene = new THREE.Scene();<br>
///////////////////////////////////////////////////////
// Option 2: Import just the parts you need.
// Вариант 2: Импорт только того, что нужно.
import { Scene } from 'three';<br>
const scene = new Scene();</pre>

При установке из <tt>npm</tt> вы почти всегда будете использовать какой-либо <a href="https://eloquentjavascript.net/10_modules.html#h_zWTXAU93DC" target="_blank" onmouseover="show('Eloquent JavaScript Chapter 10 Modules Building and bundling<br>Выразительный JavaScript Глава 10 Модули Сборка и упаковка')" onmouseout="hide()">инструмент комплектации</a>,
для объединения всех пакетов, необходимых проекту, в единственный JavaScript-файл.
Несмотря на то, что с <em>three.js</em> можно использовать любой современный JavaScript-упаковщик, наиболее популярным вариантом является
<tt><a href="https://webpack.js.org/" target="_blank" onmouseover="show('<tt>webpack</tt> - это упаковщик (bundler) статических модулей для современных<br>приложений JavaScript. При обработке приложения, <tt>webpack</tt> самостоятельно<br>строит граф зависимостей, в котором отображается каждый модуль, нужный<br>проекту, и генерирует один или несколько пакетов.')" onmouseout="hide()">webpack</a></tt>.

<div class=note_trans><b>Примечание переводчика:</b> Перевод части "Сборка и упаковка" 10 главы "Модули" от третьего издания, на которую ссылаются выше, приводится здесь... <span class='link' onclick='javascript:spoiler(this)'>... читать далее</span>
<div style='display:none;'><h3>Сборка и упаковка</h3>

На самом деле, множество JavaScript-проектов даже технически написаны не на JavaScript.
Существуют широко используемые расширения языка, такие как проверка типа диалекта, упомянутая в <a href="https://eloquentjavascript.net/08_error.html" target="_blank">главе 8</a>.
Также народ часто начинает использовать планируемые расширения языка задолго до того, как они добавляются на платформы, которые на самом деле работают с JavaScript.<br><br>

Чтобы такое стало возможным, код перекомпилируется - переводится с выбранного диалекта JavaScript в обычный старый JavaScript (или даже в более раннюю версию JavaScript) так, чтобы его могли запускать старые браузеры.<br><br>

Включение модульной программы, которая состоит из 200 различных файлов на веб-странице, создает свои собственные проблемы.
Если извлечение одного файла по сети занимает 50 миллисекунд, загрузка всей программы занимает 10 секунд или, может быть, вдвое меньше, если можно загружать несколько файлов одновременно.
Это масса потерянного времени.
Поскольку извлечение одного большого файла, как правило, происходит быстрее, чем извлечение большого количества мелких, прежде чем публиковать что-либо в Интернете, веб-программисты начали использовать инструменты, которыми сворачивают свои программы (ранее тщательно разбитые на модули) обратно в один большой файл.
Такие инструменты называют упаковщиками (bundler).<br><br>

А можно пойти дальше. Скорость передачи файлов по сети определяется, помимо количества, их размером.
Поэтому сообщество JavaScript изобрело <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BD%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" target="_blank">минификаторы (minifier - минифайер)</a>.
Это инструменты, которые берут программу JavaScript и уменьшают ее за счет автоматического удаления комментариев и пробелов, переименования привязок и замены фрагментов кода эквивалентным кодом, занимающим меньше места.<br><br>

Поэтому нередко код, находящийся в пакете NPM или работающий на веб-странице, прошел несколько этапов преобразования - преобразован из современного JavaScript в "древний" JavaScript, из формата модуля ES в CommonJS, к тому же упакован и минимизирован.
Не будем в этой книге вдаваться в подробности этих инструментов, поскольку они, как правило, скучны и быстро меняются.
Просто помните, что запускаемый вами код JavaScript, зачастую не совсем тот код, который был написан.<br>
</div></div><br>

Непосредственно через модуль <tt>three</tt> (также называемом "bare import" - "чистый импорт") доступны не все функции.
Оставшиеся популярные части библиотеки, такие как элементы управления (контролы), загрузчики и эффекты постобработки - должны импортироваться из вложенной папки <tt>examples/jsm</tt>.
Подробности смотрите <a href="#examples" onmouseover="show('Примеры')" onmouseout="hide()">ниже, в Примерах</a>.<br><br>
Узнать больше о <tt>npm</tt>-модулях можно в книге <a href="https://eloquentjavascript.net/20_node.html#h_J6hW/SmL/a" target="_blank" onmouseover="show('Выразительный JavaScript: Установка с <tt>npm</tt>')" onmouseout="hide()">Eloquent JavaScript: Installing with npm</a> (Выразительный JavaScript: Установка с <tt>npm</tt>).
<div class=note_trans><b>Примечание переводчика:</b> Перевод этой части книги смотрите здесь... <span class='link' onclick='javascript:spoiler(this)'>... читать далее</span>
<div style='display:none;'><h3>Установка с NPM</h3>
NPM, который был представлен в <a href="https://eloquentjavascript.net/10_modules.html" target="_blank">главе 10</a>, является сетевым хранилищем (репозиторием) JavaScript-модулей, многие из которых были специально написаны для Node.
При установке Node на свой компьютер, вы также получаете команду <tt>npm</tt>, с помощью которой можно взаимодействовать с данным хранилищем файлов (репозиторием).<br><br>
Основное назначение NPM - загрузка пакетов. В <a href="https://eloquentjavascript.net/10_modules.html#modules_ini" target="_blank">главе 10</a> рассматривался пакет <tt>ini</tt>.
Для извлечения и установки этого пакета на компьютер можно использовать NPM.
<pre>$ npm install ini
npm WARN enoent ENOENT: no such file or directory,
         open '/tmp/package.json'
+ ini@1.3.5
added 1 package in 0.552s<br>
$ node
> const {parse} = require("ini");
> parse("x = 1\ny = 2");
{ x: '1', y: '2' }</pre>
После запуска <tt>npm install</tt>, NPM создаст директорию с названием <tt>node_modules</tt>.
Внутри этой директории будет вложен каталог <tt>ini</tt>, в котором содержится библиотека. Можно открыть её и посмотреть код.
При вызове <tt>require("ini")</tt>, эта библиотека загружается и можно вызвать её свойство <tt>parse</tt>, для разбора файла конфигурации.<br><br>
По умолчанию NPM устанавливает пакеты в текущей директории, а не в каком-то общем месте для загружаемых файлов (для Windows это папка "Загрузки").
При использовании других менеджеров пакетов, это возможно покажется необычным, но имеются свои преимущества - каждое приложение получает полный контроль над устанавливаемыми пакетами, упрощается управление версиями и очистка при удалении приложения.<br><br>

<h4>Упаковка файлов</h4>
В примере <tt>npm install</tt> можно видеть предупреждение о том, что файла <tt>package.json</tt> на самом деле не существует. Этот файл рекомендуется создавать или вручную, или запуская команду <tt>npm init</tt>.
В нем содержатся некоторые сведения о данном проекте, такие как название и версия, а также перечисление его зависимостей.<br><br>
Симуляция робота из <a href="https://eloquentjavascript.net/07_robot.html" target="_blank">главы 7</a>, представленная в виде модулей в <a href="https://eloquentjavascript.net/10_modules.html#i_CJKk6NIC0T" target="_blank">упражнениях к главе 10</a>, может иметь вот такой файл <tt>package.json</tt>:
<pre>{
  "author": "Marijn Haverbeke",
  "name": "eloquent-javascript-robot",
  "description": "Simulation of a package-delivery robot",
  "version": "1.0.0",
  "main": "run.js",
  "dependencies": {
    "dijkstrajs": "^1.0.1",
    "random-item": "^1.0.0"
  },
  "license": "ISC"
}</pre>
Когда команда <tt>npm install</tt> запускается без указания имени устанавливаемого пакета, то NPM установит зависимости, перечисленные в <tt>package.json</tt>.
При установке конкретного пакета, ранее не указываемого в качестве зависимости, NPM добавит его в список зависимостей <tt>package.json</tt>.<br><br>

<h4>Версии</h4>
В файле <tt>package.json</tt> указывается как версия собственно самой программы, так и версии ее зависимостей.
Версии - это способ справиться с тем фактом, что каждый пакет развивается сам по себе, а код, написанный для работы с пакетом в какой-то определенный момент времени, может не работать с более поздней, измененной версией пакета.<br>
Вот <a href="https://ru.wikipedia.org/wiki/%D0%9D%D1%83%D0%BC%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B9_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F" target="_blank">статья Википедии о нумерации версий</a>.<br><br>
NPM требует, чтобы его пакеты следовали схеме, называемой <a href="https://semver.org/lang/ru/" target="_blank">семантическим версионированием</a>,
по которой в номере версии кодируется некоторые сведения о совместимости версий (не ломается старый интерфейс).
Семантическая версия состоит из трех чисел, разделенных точками, например&nbsp;<tt>2.3.0</tt>.
Каждый раз, когда добавляются новые функции, должно увеличиваться среднее число.
Каждый раз, когда нарушается совместимость, так что существующий код, использующий пакет, уже не может работать с новой версией, должно увеличиваться первое число.<br><br>
Символ <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D0%B5%D1%82" target="_blank">"карет" (<tt>^</tt>)</a> перед номером версии зависимости в файле <tt>package.json</tt> показывает, что может быть установлена любая версия, сочетаемая с данным номером.
Так например, номер версии <tt>^2.3.0</tt> будет означать, что допускается любая версия с номером больше и равным <tt>2.3.0</tt> и меньше чем <tt>3.0.0</tt>.<br><br>
Команда <tt>npm</tt> также используется для публикации новых пакетов или новых версий пакетов.
Если запустить <tt>npm publish</tt> в каталоге, где имеется файл <tt>package.json</tt>, то в реестре будет опубликован пакет с именем и версией, указанными в JSОN-файле.
Любой человек в NPM может опубликовать пакеты, но только с названием, которое ещё не использовалось, поскольку было бы страшновато, если бы случайные люди могли обновлять существующие пакеты.<br><br>
Поскольку программа <tt>npm</tt> является частью программного обеспечения, которая общается с открытой системой (реестром пакетов), то нет ничего уникального в том, что она делает.
Другая программа <tt><a href="https://classic.yarnpkg.com/ru/" target="_blank">yarn</a></tt> (<a href="http://prgssr.ru/development/yarn-ili-npm-vse-chto-vam-nuzhno-znat.html" target="_blank">вот о <tt>yarn</tt> на русском</a>),
которую можно установить из реестра NPM, выполняет ту же роль, что и <tt>npm</tt>, используя отчасти другой интерфейс и стратегию установки.<br><br>
Эта книга не будет далее углубляться в подробности использования NPM.
Более подробные сведения и способ поиска пакетов смотрите на <a href="https://npmjs.org" target="_blank">https://npmjs.org</a>.
</div></div>

<h3>Установка из CDN или статического сайта static hosting</h3>

Библиотеку <em>three.js</em> можно использовать без каких-либо систем пострения, загрузив файлы на собственный веб-сервер или воспользовавшись существующим CDN.
The three.js library can be used without any build system, either by uploading files to your own web server or by using an existing CDN.
Поскольку библиотека опирается на модули ES, любой скрипт, который ссылается на нее, должен использовать <tt>type = "module"</tt>, как показано ниже:
Because the library relies on ES modules, any script that references it must use type="module" as shown below:

<pre>&lt;script type="module"&gt;<br>
  // Find the latest version by visiting https://unpkg.com/three. The URL will
  // redirect to the newest stable release.
  // Находим последнюю версию, посетив https://unpkg.com/three.
  // URL-адрес будет перенаправлен к новейшей стабильной версии.
  import * as THREE from 'https://unpkg.com/three@&lt;VERSION&gt;/build/three.module.js';<br>
  const scene = new THREE.Scene();<br>
&lt;/script&gt;</pre>

Не все функции доступны через модуль <tt>build/three.module.js</tt>.
Оставшиеся популярные части библиотеки, такие как элементы управления (контролы), загрузчики и эффекты постобработки - должны импортироваться из вложенной папки <tt>examples/jsm</tt>.
Чтобы узнать больше смотрите &#171;Примеры&#187; ниже.<br><br>


<h3 id="examples">Примеры</h3>

Основные функции <em>three.js</em> сфокусированы на наиболее важных компонентах <a href="https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B4%D0%B2%D0%B8%D0%B6%D0%BE%D0%BA" target="_blank" onmouseover="show('Графический движок (от англ. слов - graphics engine; иногда<br>«рендерер» или «визуализатор») — промежуточное программное<br>обеспечение (англ. middleware), программный движок, основной<br>задачей которого является визуализация (рендеринг) двухмерной<br>или трёхмерной компьютерной графики. Может существовать как<br>отдельный продукт или в составе игрового движка. Может<br>использоваться для визуализации отдельных изображений или<br>компьютерного видео. Графические движки, использующееся в<br>программах по работе с компьютерной графикой (таких, как<br>3ds Max, Maya, Cinema 4D, Zbrush, Blender), обычно называются<br>«рендерерами», «отрисовщиками» или «визуализаторами». Само<br>название «графический движок» используется, как правило,<br>в компьютерных играх')" onmouseout="hide()">3D движка</a>.
Множество других полезных компонентов, таких как элементы управления (контролы), загрузчики и эффекты постобработки, являются частью каталога <tt>examples/jsm</tt>.
Они называются «примерами» (examples) и хотя их можно использовать в качестве "готовых к употреблению", они все же предназначены для переделки и подстройки.
Эти компоненты всегда синхронизируются с основной библиотекой, тогда как подобные сторонние пакеты на <tt>npm</tt> поддерживаются разными людьми и могут быть уже не актуальны.<br><br>
Примеры не требуют отдельной установки, но импортировать их нужно отдельно.
Если <em>three.js</em> был установлен с <tt>npm</tt>, можно загрузить компонент OrbitControls с помощью:
<pre>import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';<br>
const controls = new OrbitControls();</pre>
Если <em>three.js</em> был установлен из <tt>CDN</tt>, для установки других компонентов используйте тот же самый <tt>CDN</tt>.
<pre>&lt;script type="module"&gt;<br>
  // Find the latest version by visiting https://unpkg.com/three. The URL will
  // redirect to the newest stable release.
  // Находим последнюю версию, посетив https://unpkg.com/three.
  // URL-адрес будет перенаправлен к новейшей стабильной версии.
  import { OrbitControls } from 'https://unpkg.com/three@&lt;VERSION&gt;/examples/jsm/controls/OrbitControls.js';<br>
  const controls = new OrbitControls();<br>
&lt;/script&gt;</pre>
Важно, чтобы все файлы использовали одну и ту же версию. Не импортируйте разные примеры различных версий и не используйте примеры от другой версии, отличной от версии самой библиотеки <em>three.js</em>.<br><br>


<h3>Совместимость</h3>

<h4>CommonJS imports</h4>
<div class=note_trans><b>Примечание переводчика:</b> CommonJS был проектом, целью которого было установить соглашения по модульной экосистеме для JavaScript вне веб-браузера.<span class='link' onclick='javascript:spoiler(this)'>... читать далее</span>
<div style='display:none;'>Основной причиной его создания было серьезное отсутствие общепринятой формы модулей скриптов JavaScript, которые можно было бы повторно использовать в средах, отличающихся от среды,
предоставляемой обычным веб-браузером, например веб-сервер или родные настольные приложения, которые запускают сценарии JavaScript.<br>
С появлением и развитием Node.js, CommonJS, как отдельный проект, устарел и с ноября 2014 года более не развивается.<br>
В Node.js присутствует в виде формата (файлы с расширением <tt>.cjs</tt>)</div></div>

В то время как большинство современных JavaScript-упаковщиков (bundler) сейчас поддерживают модули ES по умолчанию, некоторые старые сборочные инструменты этого делать не могут.
В таких случаях скорее всего, можно настроить упаковщик (bundler) для понимания ES-модулей: например, для <a href="http://browserify.org/" target="_blank">Browserify</a> нужен только плагин <a href="https://github.com/babel/babelify" target="_blank">babelify</a>.<br><br>


<h4>Карты импорта Import maps</h4>

Пути импорта при установке с <tt>npm</tt> отличаются в сравнении с путями при установке со статического сайта или CDN. Этот вопрос привносит неудобства для обеих групп пользователей.
Разработчики с инструментами сборки и упаковщиками предпочитают не относительные пути, а пустые спецификаторы пакетов (например, <tt>'three'</tt>), при этом файлы в папке <tt>examples/</tt> используют относительные ссылки на <tt>three.module.js</tt>, не соответствующие этим ожиданиям.
Developers with build tools and bundlers prefer bare package specifiers (e.g. 'three') rather than relative paths, and files in the examples/ folder use relative references to three.module.js that don't follow this expectation.

Тем, кто не использует инструменты сборки (для быстрого создания прототипов, обучения или личных предпочтений) также может не понравиться тот относительный импорт, который требует определенных структур папок и менее прощающий, чем глобальное пространство имен <tt>THREE.*</tt>.
Those who do not use build tools — for fast prototyping, learning, or personal preference — may similarly dislike those relative imports, which require certain folder structures and are less forgiving than a global THREE.* namespace.<br><br>

Когда <a href="https://github.com/WICG/import-maps" target="_blank">карты импорта</a> станут широко доступными, мы надеемся удалить эти относительные пути, заменив их пустыми спецификаторами пакетов к имени пакета <tt>npm</tt>, <tt>'three'</tt>.
We hope to remove these relative paths when import maps become broadly available, replacing them with bare package specifiers to the <tt>npm</tt> package name, <tt>'three'</tt>.

Это более точно соответствует ожиданиям инструментов сборки для пакетов <tt>npm</tt> и позволяет обеим группам пользователей при импорте файла писать абсолютно одинаковый код.
Для пользователей, которые хотят уйти от применения инструментов сборки, простое сопоставление
<a href="https://ru.wikipedia.org/wiki/JSON" target="_blank" onmouseover="show('JSON (сокращ. англ. слов JavaScript Object Notation, обычно произносится<br>как /dʒeɪsən/ JAY-sən) — текстовый формат обмена данными, основанный<br>на JavaScript. Как и многие другие текстовые форматы, JSON легко читается<br>людьми. Формат JSON был разработан Дугласом Крокфордом.<br>Несмотря на происхождение от JavaScript (точнее, от подмножества языка<br>стандарта ECMA-262 1999 года), формат считается независимым от языка<br>и может использоваться практически с любым языком программирования.')" onmouseout="hide()">JSON</a>
может направить весь импорт в CDN или папку статических файлов.
В качестве эксперимента, на данный момент, можно попробовать использовать более простой импорт с полифиллом карты импорта, как показано в нашем <a href="https://glitch.com/edit/#!/three-import-map?path=index.html" target="_blank">примере карты импорта</a>.<br><br>


<h4>Node.js</h4>

Использование <em>three.js</em> в <a href="https://eloquentjavascript.net/20_node.html" target="_blank">Node.js</a> может быть затруднено по двум причинам:<br><br>
Во-первых, поскольку <em>three.js</em> создан для Интернета, он зависит от браузера и API DOM, которые не всегда присутствуют в Node.js.
Некоторые из этих проблем могут быть решены с помощью прокладок, таких как <tt><a href="https://github.com/stackgl/headless-gl" target="_blank">headless-gl</a></tt>,
или путем замены компонентов, таких как <a href="../loaders/textureLoader.htm" onmouseover="show('TextureLoader')" onmouseout="hide()">TextureLoader</a>, на пользовательские альтернативы.
Другие функции API DOM могут быть глубоко переплетены с используемым их кодом и обойти их гораздо сложнее.
Для усовершенствования поддержки Node.js приветствуются простые и понятные запросы, но сначала рекомендуется вскрыть проблему для обсуждения этих улучшений.<br><br>

Во-вторых, поддержка Node.js для модулей ES ... сложна.
Начиная с 12 версии Node.js, базовая библиотека <em>three.js</em> может быть импортирована как модуль CommonJS с помощью <tt>require('three')</tt>.
Однако с большинством примеров компонентов в <tt>examples/jsm</tt> этого сделать нельзя.
Возможно в следующих версиях Node.js эта проблема будет решена, но между тем могут потребоваться обходные пути,
например <tt><a href="https://github.com/standard-things/esm" target="_blank" onmouseover="show('загрузчик модулей ECMAScript')" onmouseout="hide()">esm</a></tt>, для того чтобы приложение Node.js могло распознавать модули ES.<br><br>

<br><br>
</body></html>