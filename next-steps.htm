<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Three.js</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>
<body>
<h2 class=head1>Следующие действия</h2>
<h1 id="1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Как это все обновлять</h1>
Все объекты по умолчанию автоматически обновляют свои матрицы, если были добавлены на сцену при помощи
<pre>var object = new THREE.Object3D;
scene.add( object );</pre>
или если они являются дочерними по отношению к другому объекту, уже добавленному на сцену:
<pre>var object1 = new THREE.Object3D;
var object2 = new THREE.Object3D;<br>
object1.add( object2 );
scene.add( object1 ); //object1 and object2 will automatically update their matrices
//object1 и object2 будут автоматически обновлять свои матрицы</pre>
Впрочем, если известно что объект будет статичным, можно запретить автоматическое обновление и обновлять матрицу трансформации вручную, когда потребуется.
<pre>object.matrixAutoUpdate  = false;
object.updateMatrix();</pre><br>

<h2>Geometries</h2>
<div class=note_trans><b>Примечание переводчика:</b> Здесь рассматривается обновление геометрических параметров объекта, т.е. вершины, грани, их расположение, нормали, цвета и т.д.</div>
<h3><a href="core.htm#2">BufferGeometry</a></h3>
BufferGeometries сохраняют информацию (такую как положение вершин, индексы граней, нормали, цвета, текстурные координаты
(<a href="https://ru.wikipedia.org/wiki/UV-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" onmouseover="show('соответствие между координатами на поверхности трёхмерного объекта (X, Y, Z)<br>и координатами на текстуре (U, V - эти буквы обозначают оси двумерной текстуры,<br>потому что «X», «Y» и «Z» уже используются для обозначения осей 3D-объекта<br>в пространстве модели). Значения U и V обычно изменяются от 0 до 1.');" onmouseout="hide()">UV</a>)
и все атрибуты, установленные пользователем) в <a href="core.htm#2">буферах</a>, которые являются <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" target="_blank">типизованными массивами</a> (<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Typed_arrays" target="_blank">здесь</a> описание этих массивов на русском языке).
Это делает работу BufferGeometries в общем-то быстрее, по сравнению с обычными Geometries за счет того, что с ними сложнее работать.<br><br>
Что касается обновления BufferGeometries, то самое главное для понимания, не стоит изменять размер буферов (это очень затратно, по существу равнозначно созданию новой геометрии). Однако можно обновлять содержимое буферов.<br><br>
Это значит, если известно, что какой-нибудь атрибут вашей BufferGeometry будет расти (например, количество вершин), то следует изначально выделить буфер, достаточно большой, для хранения любого числа новых вершин, которые могут быть созданы.
Конечно, это также означает, что для вашей <tt>BufferGeometry</tt> существует максимальный размер - нет способа создать <tt>BufferGeometry</tt>, которую можно было бы успешно расширять до бесконечности.<br><br>
В качестве примера попробуем нарисовать линию, которая увеличивается во время визуализации. Выделим место в буфере для 500 вершин, но сначала, при помощи метода <tt><a href="core.htm#2drawRange">BufferGeometry.drawRange</a></tt>, нарисуем только две.
<pre>var MAX_POINTS = 500;<br>
// geometry  (геометрия)
var geometry = new THREE.BufferGeometry();<br>
// attributes (атрибуты)
var positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point (3 вершины на точку)
geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );<br>
// draw range (рисуем ряд точек)
var drawCount = 2; // draw the first 2 points, only (рисуем только первые две точки)
geometry.setDrawRange( 0, drawCount );<br>
// material (материал)
var material = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 2 } );<br>
// line (линия)
var line = new THREE.Line( geometry,  material );
scene.add( line );</pre>
Далее будем случайным образом добавлять точки к линии при помощи шаблона в виде:
<pre>var positions = line.geometry.attributes.position.array;<br>
var x, y, z, index;
x = y = z = index = 0;<br>
for ( var i = 0, l = MAX_POINTS; i &lt; l; i ++ ) {<br>
    positions[ index ++ ] = x;
    positions[ index ++ ] = y;
    positions[ index ++ ] = z;<br>
    x += ( Math.random() - 0.5 ) * 30;
    y += ( Math.random() - 0.5 ) * 30;
    z += ( Math.random() - 0.5 ) * 30;<br>
}</pre>
Если нужно изменить <em>количество точек</em>, отображаемых после первой визуализации, сделайте следующее:
<pre>line.geometry.setDrawRange( 0, newValue );</pre>
Если, после первой визуализации, нужно изменить значения данных положения, следует установить флаг <tt>needsUpdate</tt>, вот так:
<pre>line.geometry.attributes.position.needsUpdate = true;
 // required after the first render (запрашивается после первой визуализации)</pre>
<a href="http://jsfiddle.net/w67tzfhx/" target="_blank">Вот пУтанка</a>, представленная анимированной линией, которую можно приспособить под свои нужды.<br><br>

<h4>Примеры:</h4>
<pre><a href="https://threejs.org/examples/#webgl_custom_attributes" target="_blank">WebGL / custom / attributes</a>
<a href="https://threejs.org/examples/#webgl_buffergeometry_custom_attributes_particles" target="_blank">WebGL / buffergeometry / custom / attributes / particles</a></pre><br>

<h3><a href="core.htm#7">Geometry</a></h3>
Следующие флаги управляют обновлением различных атрибутов геометрии. Устанавливайте флаги только для атрибутов, требующих обновления, так как обновления - затратная вещь. После изменения буферов эти флаги автоматически сбрасываются обратно к значению <tt>false</tt>.
Если требуется продолжать обновление буферов, нужно сохранить их как <tt>true</tt>. Обратите внимание, что это относится только к <a href="core.htm#7">Geometry</a>, а не к <a href="core.htm#2">BufferGeometry</a>.
<pre>var geometry = new THREE.Geometry();
geometry.verticesNeedUpdate = true;
geometry.elementsNeedUpdate = true;
geometry.morphTargetsNeedUpdate = true;
geometry.uvsNeedUpdate = true;
geometry.normalsNeedUpdate = true;
geometry.colorsNeedUpdate = true;
geometry.tangentsNeedUpdate = true;</pre>
Кроме этого, в версиях, предшествующих <a href="https://github.com/mrdoob/three.js/releases/tag/r66" target="_blank">r66</a>, сеткам (mesh) необходимо включать флаг <tt>dynamic</tt> (для сохранения внутренних типизованных массивов):
<pre>// removed after r66 (удаляется после версии r66)
geometry.dynamic = true;</pre><br>
<h4>Пример:</h4>
<pre><a href="https://threejs.org/examples/#webgl_geometry_dynamic" target="_blank">WebGL / geometry / dynamic</a></pre><br>

<h3>Материалы</h3>
Все значения <span class="lnk" onmouseover="show('В шейдерах существует три типа переменных: униформы (uniforms), атрибуты<br>(attributes) и вариации (varyings):<br>'
+'&nbsp; &nbsp; &nbsp; Униформы (uniforms) - это переменные, что имеют единообразное значение<br>для всех вершин; освещение, туман и карты тени - вот примеры данных, которые<br>будут храниться в униформах. Обращаться к униформам можно как с помощью<br>вершинного шейдера, так и с помощью шейдера фрагментов.<br>'
+'&nbsp; &nbsp; &nbsp; Атрибуты (attributes) - это переменные, связанные с каждой вершиной -<br>например, положение вершины, нормаль к грани и цвет вершины - это все<br>примеры данных, которые будут хранится в атрибутах. Атрибуты могут быть<br>доступны только внутри вершинного шейдера.<br>'
+'&nbsp; &nbsp; &nbsp; Вариации (varyings) - это переменные, которые передаются из вершинного<br>шейдера в шейдер фрагмента. Для каждого фрагмента значение каждой<br>вариации будет плавно интерполироваться из значений смежных вершин.')" onmouseout="hide()">переменных-униформ</span> могут быть свободно изменены (например, цвета, текстуры, непрозрачность и так далее), значения отправляются в шейдер с каждым кадром.
<div class=note_trans><b>Примечание переводчика:</b> В области компьютерной графики, шейдер - это компьютерная программа<a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>используемая для создания оттенков (т.е. для шейдинга, от англ. слова shade - оттенок, тон цвета, тень): производства соответствующих уровней освещенности, затемнения и окрашивания изображения, или, на современном этапе, также для создания спецэффектов и пост-обработки видео.<br><br>
Шейдеры рассчитывают эффекты визуализации с помощью процессора видеокарты, хотя это и не обязательное условие.
Языки программирования шейдеров обычно используются для написания <span class="lnk" onmouseover="show('programmable rendering pipeline – программируемый конвейер<br>рендеринга – конвейер графического процессора (GPU) с<br>изменяемыми (перепрограммируемыми) функциями');" onmouseout="hide()">программируемого конвейера рендеринга</span>
<span class="lnk" onmouseover="show('сокращение от англ. слов graphics processing unit<br>- блок графических вычислений или графический<br>процессор или попросту - процессор видеокарты');" onmouseout="hide()">GPU</span>,
который в основном заменил <span class="lnk" onmouseover="show('fixed-function pipeline – конвейер с фиксированными<br>(постоянными) функциями, не предусматривающий<br>программирования (перепрограммирования)');" onmouseout="hide()">конвейер с фиксированными функциями</span>,
допускающий только общие преобразования геометрии и функции закрашивания пикселей; с использованием шейдеров могут быть применены и настраиваемые эффекты.
Положение, оттенок, насыщенность, яркость и контрастность всех пикселей вершин или текстур, используемых для построения окончательного изображения могут быть изменены "на лету", с использованием алгоритмов, определенных в шейдере, а также могут быть изменены при помощи внешних переменных и текстур, вводимых программой, вызывающей шейдер.
<br><br>
<span style='float:right; margin-top:-16px; background-color:#ffffe8;'><em>(из <a href='https://en.wikipedia.org/wiki/Shader' target='_blank'>Википедии</a>, перевод мой)</em>&nbsp;&nbsp;&nbsp;</span></div></div><br>
Параметры связанные с GLstate также могут быть изменены в любой момент (<tt>depthTest</tt>, <tt>blending</tt>, <tt>polygonOffset</tt>, и т.д.).<br><br>
Плоское (flat) / плавное (smooth) затенение <span class="lnk" onmouseover="show('здесь смысл слова &quot;запекается&quot; в том,<br>что статичные данные о затенении<br>фиксируются и сохраняются')" onmouseout="hide()">"запекается"</span> в нормалях. Требуется сброс буфера нормалей (смотрите выше).<br><br>
Следующие свойства нельзя просто так изменить во время выполнения (после того, как материал был визуализирован хотя бы раз):
<ul><li>типы и число униформ</li>
<li>типы и число источников освещения</li>
<li>наличие или отсутствие
<ul><li>текстуры (texture)</li>
<li>тумана (fog)</li>
<li>цвета вершин (vertex colors)</li>
<li><span class="lnk" onmouseover="show('Скининг (от английского слова skin - кожа, skinning - процесс<br>создания кожи, встречается также написание скиннинг)<br>- это один из этапов постановки 3d-персонажа, когда модель<br>персонажа привязывается (скинится) к скелету.<br>'
+'Делается это для того, чтобы при движении скелета двигалась и<br>сама модель персонажа.<br>'
+'Это достаточно трудоемкий процесс, поскольку нужно правильно<br>назначить вес (англ. weight) для каждой вершины модели.<br>Чем больше вес, тем больше влияет конкретная кость<br>на конкретную вершину 3d-модели.');" onmouseout="hide()">скининга</span> (skinning)</li>
<li><span class="lnk" onmouseover="show('Морфинг (англ. morphing, трансформация) — технология в компьютерной<br>анимации, визуальный эффект, создающий впечатление плавной<br>трансформации одного объекта в другой. Встречается в трёхмерной<br>и двухмерной (как растровой, так и векторной) графике.<br>'
+'Для создания эффекта используются как минимум два изображения,<br>на которых художник задаёт в зависимости от использующегося<br>программного обеспечения опорные фигуры или ключевые точки<br>(т. н. маркеры, или метки), которые помогают компьютеру выполнить<br>правильный морфинг, то есть создать изображения промежуточных<br>состояний (интерполируя имеющиеся данные).<br>'
+'Морфинг также часто используется для создания анимации, когда не<br>стоит задача добиться эффекта превращения одного объекта в другой,<br>а требуется лишь выстроить промежуточные состояния между двумя<br>(и более) ключевыми положениями анимируемого объекта.');" onmouseout="hide()">морфинга</span> (morphing)</li>
<li><span class="lnk" onmouseover="show('Теневая карта (англ. shadow map) - способ моделирования теней в<br>трёхмерной компьютерной графике. Этот способ используется при<br>создании как отображаемых, так и анимируемых в реальном<br>времени трехмерных сцен и широко применяется в киноиндустрии<br>и компьютерных играх.<br>'
+'Традиционный способ создания теневых карт основан на<br>использовании Z-буфера (буфера глубины). Сначала происходит<br>построение сцены в Z-буфер с точки зрения источника света,<br>чтобы установить видимые из этой точки пикселы и расстояния до<br>них - таким образом формируется теневая карта, представляющая<br>собой двухмерную текстуру. После этого сцена перестраивается<br>уже с точки зрения наблюдателя со сравнением текстурных<br>координат с теневой картой; если такое сравнение говорит, что<br>соответствующий пиксел невидим с точки зрения источника света<br>и, следовательно, должен быть затенен, он закрашивается<br>темным цветом.');" onmouseout="hide()">теневой карты</span> (shadow map)</li>
<!-- https://en.wikipedia.org/wiki/Shadow_mapping
http://steps3d.narod.ru/tutorials/shadow-map-tutorial.html -->
<li><span class="lnk" onmouseover="show('Значение альфа-канала входит в качестве четвёртой компоненты в<br>вектор цвета в формате RGBA. Альфа-компонент определяет<br>непрозрачность материала в диапазоне от 1.0 означающего полную<br>непрозрачность до 0.0, означающего полную прозрачность.<br>'
+'Для того чтобы создавать прозрачные и полупрозрачные объекты,<br>необходимо разрешить тестировать буфер альфа-канала и включить<br>механизм под названием альфа-смешивание.<br>'
+'При включённом альфа-тесте сравнивается входящее значение<br>альфа-канала с эталонным значением. Фрагмент принимается или<br>отклоняется в зависимости от результатов сравнения.');" onmouseout="hide()">альфа-теста</span> (alpha test)</li>
</ul></li></ul>
<!-- https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B5%D0%BB%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%86%D0%B8%D1%8F - скелетная анимация -->
Изменения в них требуют создания новой шейдерной программы. Нужно будет установить
<pre>material.needsUpdate = true</pre>
Имейте в виду, что это может быть довольно медленно и вызывать подергивание кадров (особенно в Windows, поскольку шейдерная компиляция в DirectX медленнее, чем в OpenGL).<br><br>
Для повышения плавности работы можно в некоторой степени имитировать изменения этих функций, с помощью «фиктивных» значений, таких как освещение с нулевой интенсивностью, белых текстур или тумана с нулевой плотностью.<br><br>
Можно свободно изменять материал, используемый для частей геометрии, однако нельзя изменять способ разделения объекта на части (в соответствии с материалами граней).

<h4>Если во время выполнения нужны разные конфигурации материалов:</h4>
Если число материалов / частей невелико, можно заблаговременно предварительно разделить объект
(например, для человека - волосы (hair) / лицо (face) / тело (body) / верхняя одежда (upper clothes) / брюки (trousers),
для автомобиля - перед (front) / боковые стороны (sides) / верх (top) / стекла (glass) / шины (tire) / салон (interior)).<br><br>
Если число велико (к примеру каждое лицо/грань может быть потенциально различным), рассмотрите другое решение, такое как использование атрибутов/текстур для приведения к другому внешнему виду.
<h4>Примеры:</h4>
<pre><a href="https://threejs.org/examples/#webgl_materials_cars" target="_blank">WebGL / materials / cars</a>
<a href="https://threejs.org/examples/#webgl_postprocessing_dof" target="_blank">WebGL / webgl_postprocessing / dof</a></pre><br>

<h3>Текстуры</h3>
Если текстуры изображения, элемента canvas, видео и данных были изменены, то у них должен быть установлен следующий флаг:
<pre>texture.needsUpdate = true;</pre>
Обновление целей визуализации произойдет автоматически.
<h4>Примеры:</h4>
<pre><a href="https://threejs.org/examples/webgl_materials_video" target="_blank">WebGL / materials / video</a>
<a href="https://threejs.org/examples/webgl_rtt" target="_blank">WebGL / rtt</a></pre><br>

<h3>Камеры</h3>
Положение в пространстве и направление съемки камеры обновляются автоматически. Если нужно изменить параметры
<ul><li><tt>fov</tt> (поле просмотра)</li>
<li><tt>aspect</tt> (соотношение сторон)</li>
<li><tt>near</tt> (ближняя плоскость отсечения)</li>
<li><tt>far</tt> (дальняя плоскость отсечения)</li></ul>
то требуется пересчитать матрицу проекции:
<pre>camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();</pre><br><br>


<h2 id="1.0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Как удалять объекты</h2>
Одной из важных сторон повышения производительности и предотвращения утечек памяти в приложении является избавление от неиспользуемых библиотечных объектов.
Всякий раз, при создании экземпляра объекта от библиотеки <em>three.js</em>, выделяется определенный объем памяти.
Впрочем, <em>three.js</em> создает для определенных объектов, таких как геометрические элементы или материалы, связанные с WebGL объекты, такие как буферы или шейдерные программы, необходимые для визуализации (рендеринга).
Важно подчеркнуть, что эти объекты не высвобождаются автоматически.
Вместо этого, для высвобождения таких ресурсов, приложение должно использовать специальный API. Данное руководство представляет краткий обзор того, как этот API используется и какие объекты актуальны в этой ситуации.<br><br>

<h3>Геометрические элементы</h3>
Геометрический элемент обычно представляет сведения о вершинах, определяемые как набор атрибутов.
<em>three.js</em> внутри, для каждого атрибута, создает объект типа <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer" target="_blank" onmouseover="show('Интерфейс WebGLBuffer является частью WebGL API и представляет<br>непрозрачный буферный объект, хранящий такие данные, как вершины<br>или цвета. Объект WebGLBuffer не определяет своих собственных<br>методов или свойств и его содержимое не доступно напрямую.')" onmouseout="hide()">WebGLBuffer</a>.
Эти объекты удаляются только вызовом метода <tt><a href="core.htm#2dispose" onmouseover="show('BufferGeometry.dispose()')" onmouseout="hide()">BufferGeometry.dispose()</a></tt>.
Если в приложении стал ненужным геометрический элемент, выполните данный метод, чтобы высвободить все, связанные с ним, ресурсы.<br><br>

<h3>Материалы</h3>
Материал определяет способ отображения объектов. <em>three.js</em> использует сведения из описания материала для создания шейдерной программы для визуализации (рендеринга).
Шейдерные программы могут быть удалены только при удалении соответствующего материала. Из соображений производительности, <em>three.js</em> пытается по возможности повторно использовать существующие программы шейдеров.
Поэтому шейдерная программа удаляется только в том случае, если удаляются все связанные с ней материалы. Можно затребовать удаление материала с помощью метода <tt><a href="materials.htm#3dispose" onmouseover="show('Material.dispose()')" onmouseout="hide()">Material.dispose()</a></tt>.<br><br>

<h3>Текстуры</h3>
Удаление материала не влияет на текстуры. Они обрабатываются отдельно, поскольку одна и та же текстура может одновременно использоваться несколькими материалами.
Всякий раз, при создании экземпляра <a href="textures.htm#6" onmouseover="show('Texture')" onmouseout="hide()">Texture</a>,
<em>three.js</em> внутри создает экземпляр <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture" target="_blank" onmouseover="show('Интерфейс WebGLTexture является частью API WebGL и представляет<br>собой непрозрачный объект текстуры, обеспечивающий хранение и<br>строение операций текстурирования.<br>Объект WebGLTexture не определяет своих собственных методов или<br>свойств и его содержимое не доступно напрямую.')" onmouseout="hide()">WebGLTexture</a>.
Подобно буферам, такой объект может быть удален только путем вызова метода <tt><a href="textures.htm#6dispose" onmouseover="show('Texture.dispose()')" onmouseout="hide()">Texture.dispose()</a></tt>.<br><br>

<h3>Целевые буферы визуализации</h3>
Для реализации пользовательских назначений рендеринга, объекты типа <a href="renderers.htm#1.2" onmouseover="show('WebGLRenderTarget')" onmouseout="hide()">WebGLRenderTarget</a>
выделяют не только экземпляр <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture" target="_blank" onmouseover="show('Интерфейс WebGLTexture является частью API WebGL и представляет<br>собой непрозрачный объект текстуры, обеспечивающий хранение и<br>строение операций текстурирования.<br>Объект WebGLTexture не определяет своих собственных методов или<br>свойств и его содержимое не доступно напрямую.')" onmouseout="hide()">WebGLTexture</a>,
но также и буферы <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLFramebuffer" target="_blank" onmouseover="show('Интерфейс WebGLFramebuffer является частью API WebGL и представляет<br>собой набор буферов, которые служат в качестве места назначения<br>визуализации (рендеринга).<br>Объект WebGLFramebuffer не определяет своих собственных методов или<br>свойств и его содержимое не доступно напрямую.')" onmouseout="hide()">WebGLFramebuffer</a>
и <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderbuffer" target="_blank" onmouseover="show('Интерфейс WebGLRenderbuffer является частью API WebGL и представляет<br>собой буфер, который может содержать изображение или может быть<br>источником или целью операции визуализации (рендеринга).<br>Объект WebGLRenderbuffer не определяет своих собственных методов или<br>свойств и его содержимое не доступно напрямую.')" onmouseout="hide()">WebGLRenderbuffer</a>.
Эти объекты высвобождаются только при выполнении метода <tt><a href="renderers.htm#1.2dispose" onmouseover="show('WebGLRenderTarget.dispose()')" onmouseout="hide()">WebGLRenderTarget.dispose()</a></tt>.<br><br>

<h3>Прочие объекты</h3>
Существуют и другие классы из каталого примеров, вроде элементов управления (контролов) или каналов постобработки, предоставляющих методы <tt>dispose()</tt> для удаления внутренних прослушивателей событий или целевых буферов визуализации.
В общем, рекомендуется проверять API или документацию класса и отслеживать метод <tt>dispose()</tt>. Если он присутствует, следует использовать его при очистке.<br><br>

<h3>ЧАсто задаваемые ВОпросы</h3>
<h4>Почему <em>three.js</em> не может удалять объекты автоматически?</h4>
<div class=list>Этот вопрос задавался сообществом много раз, поэтому важно четко его разъяснить. По факту, <em>three.js</em> не знает времени жизни или области действия сущностей, созданных пользователем, таких как геометрические элементы или материалы.
Все это - зона ответственности приложения. Например, если даже материал в настоящий момент не используется в визуализации, он может стать необходимым в следующем кадре.
Поэтому, если приложение решает, что некий объект может быть удален, оно должно уведомить движок посредством вызова соответствующего метода <tt>dispose()</tt>.</div><br>

<h4>Удаляются ли при удалении сетки (mesh) со сцены, её геометрические элементы и материал?</h4>
<div class=list>Нет, следует явным образом удалять геометрические элементы и материал с помощью метода <tt>dispose()</tt>.
Имейте в виду, что геометрические элементы и материалы могут быть общими для таких трехмерных объектов, как сетки (mesh).</div><br>

<h4>Предоставляет ли <em>three.js</em> сведения о количестве кэшированных объектов?</h4>
<div class=list>Да. Это возможно при анализе <tt><a href="renderers.htm#1.1info" onmouseover="show('WebGLRenderer.info')" onmouseout="hide()">WebGLRenderer.info</a></tt>,
специального свойства визуализатора (рендерера) с целым рядом статической информации о памяти видеокарты и процессе визуализации.
Среди прочего, там говорится о количестве, сохраняемых внутри, текстур, геометрических элементов и шейдерных программ.
Если замечаете проблемы с производительностью в приложении, рекомендуется отладить это свойство для упрощения определения утечки памяти.<br>
Внутренние ресурсы для текстуры выделяются, только если изображение полностью загружено. Если вы удаляете текстуру до загрузки изображения, ничего не произойдет. Нет выделенных ресурсов, нет и необходимости в очистке.</div><br>

<h4>Что произойдет при вызове метода <tt>dispose()</tt> на текстуру, если изображение еще не загружено?</h4>
<div class=list>Внутренние ресурсы для текстуры выделяются, только если изображение полностью загружено. Если вы удаляете текстуру до загрузки изображения, ничего не произойдет. Нет выделенных ресурсов, нет и необходимости в очистке.</div><br>

<h4>Что произойдет, если вызвать метод <tt>dispose()</tt>, а затем использовать соответствующий объект на более позднем этапе?</h4>
<div class=list>Удаленные внутренние ресурсы будут вновь созданы движком. Так что, никакой ошибки во время выполнения не произойдет, но возможно будет заметно негативное влияние на производительность в текущем кадре, особенно при компиляции шейдерных программ.</div><br>

<h4>Как управлять объектами <em>three.js</em> в моем приложении? Как узнать, что можно их удалять?</h4>
<div class=list>В общем, конкретных рекомендаций для этого нет. Это сильно зависит от каждого конкретного случая использования, когда уместен вызов <tt>dispose()</tt>. Важно подчеркнуть, что не всегда и все время нужно удалять объекты.
Хороший пример показать это - игра, состоящая из нескольких уровней. Прекрасный момент для удаления объектов - переключение уровня. Приложение может пройти сквозь старую сцену и избавиться от всех устаревших материалов, геометрических элементов и текстур.
Как упоминалось в предыдущем вопросе, ошибка во время выполнения не происходит, если вы удаляете объект, который фактически все еще используется. Худшее, что может произойти, это падение производительности одиночного кадра.</div><br>

<h4>Примеры, демонстрирующие использование метода <tt>dispose()</tt></h4>
<pre><a href="https://threejs.org/examples/webgl_test_memory" target="_blank">WebGL / test / memory</a>
<a href="https://threejs.org/examples/webgl_test_memory2" target="_blank">WebGL / test / memory2</a></pre><br><br>


<h2 id="1a">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Как создать VR-контент</h2>
В этом руководстве представлен краткий обзор основных компонентов веб-приложений
<a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C" target="_blank" onmouseover="show('Виртуальная реальность, сокращ. от англ. слов virtual reality - искусственная<br>реальность) — созданный техническими средствами мир, передаваемый<br>человеку через его ощущения: зрение, слух, осязание и другие.<br>Виртуальная реальность имитирует как воздействие, так и реакции на<br>воздействие. Для создания убедительного комплекса ощущений реальности<br>компьютерный синтез свойств и реакций виртуальной реальности<br>производится в реальном времени.')" onmouseout="hide()">VR</a>, сделанных с помощью <em>three.js</em>.<br><br>

<h3>Последовательность действий</h3>
Вначале следует включить в свой проект <a href="https://github.com/mrdoob/three.js/blob/master/examples/js/vr/WebVR.js" target="_blank">WebVR.js</a>.
<pre><script src="/path/to/WebVR.js"></script></pre>
<tt>WEBVR.createButton()</tt> (из WebVR.js) делает две важные вещи: создает кнопку, которая показывает совместимость VR, а также, если пользователь активирует кнопку, запускает сеанс VR.
Единственное, что нужно сделать, это добавить в приложение следующую строку кода.
<pre>document.body.appendChild( WEBVR.createButton( renderer ) );</pre>
Затем указываем свой экземпляр WebGLRenderer'а для включения визуализации (рендеринга) VR.
<pre>renderer.vr.enabled = true;</pre>
Наконец нужно настроить цикл анимации, поскольку нельзя использовать хорошо известную функцию
<tt><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank">window.requestAnimationFrame()</a></tt>.
Для проектов VR используется <tt><a href="renderers.htm#1.1setAnimationLoop" onmouseover="show('WebGLRenderer.setAnimationLoop')" onmouseout="hide()">setAnimationLoop</a></tt>. Минимальный код выглядит так:
<pre>renderer.setAnimationLoop( function () {
  renderer.render( scene, camera );
} );</pre><br>

<h3>Дальнейшие шаги</h3>
Чтобы увидеть этот рабочий процесс в действии, посмотрите некоторые из официальных примеров WebVR.
<pre><a href="https://threejs.org/examples/#webvr_ballshooter" target="_blank">WebVR / ballshoter</a>
<a href="https://threejs.org/examples/#webvr_cubes" target="_blank">WebVR / cubes</a>
<a href="https://threejs.org/examples/#webvr_dragging" target="_blank">WebVR / dragging</a>
<a href="https://threejs.org/examples/#webvr_lorenzattractor" target="_blank">WebVR / lorenzattractor</a>
<a href="https://threejs.org/examples/#webvr_panorama" target="_blank">WebVR / panorama</a>
<a href="https://threejs.org/examples/#webvr_paint" target="_blank">WebVR / paint</a>
<a href="https://threejs.org/examples/#webvr_rollercoaster" target="_blank">WebVR / rollercoaster</a>
<a href="https://threejs.org/examples/#webvr_sandbox" target="_blank">WebVR / sandbox</a>
<a href="https://threejs.org/examples/#webvr_sculpt" target="_blank">WebVR / sculpt</a>
<a href="https://threejs.org/examples/#webvr_vive_paint" target="_blank">WebVR / vive / paint</a>
<a href="https://threejs.org/examples/#webvr_vive_sculpt" target="_blank">WebVR / vive / sculpt</a></pre>
<br><br>

<h2 id="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Матричные преобразования</h2>
В <em>three.js</em> для кодирования 3-мерных преобразований - перемещения (изменения положения), вращения и масштабирования используются <b>матрицы</b>.
Каждый экземпляр <a href="core.htm#14" onmouseover="show('Object3D')" onmouseout="hide()">Object3D</a> имеет свойство <a href="core.htm#14matrix" onmouseover="show('Object3D.matrix')" onmouseout="hide()">matrix</a>, в котором хранится положение, угол поворота и масштаб этого объекта.
На этой странице описывается как обновлять преобразование (трансформацию) объекта.<br><br>

<h4>Преимущества свойств и <tt>matrixAutoUpdate</tt></h4>
Существует два способа обновления преобразования объекта:
<ol><li>Изменить свойства объекта <tt>position</tt>, <tt>quaternion</tt> и <tt>scale</tt>, и позволить Three.js пересчитать матрицу объекта с этими свойствами:
<pre>object.position.copy(start_position);
    object.quaternion.copy(quaternion);</pre>
По умолчанию, свойство <tt>matrixAutoUpdate</tt> устанавливается равным <tt>true</tt>, так что матрица будет пересчитана автоматически.
Если объект статичен или нужно вручную определять когда будет происходить пересчет матрицы, наилучшую производительность можно получить установкой этого свойства как <tt>false</tt>:
<pre>object.matrixAutoUpdate = false;</pre>
И после изменения каких-либо свойств, вручную обновить матрицу:
<pre>object.updateMatrix();</pre></li>
<li>Непосредственно изменить матрицу объекта. Класс <a href="math.htm#11" onmouseover="show('Matrix4')" onmouseout="hide()">Matrix4</a> имеет различные методы для изменения матрицы:
<pre>object.matrix.setRotationFromQuaternion(quaternion);
    object.matrix.setPosition(start_position);
    object.matrixAutoUpdate = false;</pre>
Обратите внимание, что в этом случае свойство <tt>matrixAutoUpdate</tt> <b>должно</b> быть установлено как <tt>false</tt>, при этом следует убедиться, что <b>не</b> было вызова <tt>updateMatrix</tt>.
Вызов <tt>updateMatrix</tt> перебьет изменения матрицы, сделанные вручную, пересчитав матрицу для <tt>position</tt>, <tt>scale</tt> и так далее.</li></ol><br>

<h4>Матрицы объекта и "мира"</h4>
<a href="core.htm#14matrix" onmouseover="show('Object3D.matrix')" onmouseout="hide()">Матрица объекта</a> хранит изменения объекта <em>относительно</em> родительского объекта; для получения изменеия объекта в <em>"мировых"</em> координатах, следует обращаться к <tt><a href="core.htm#14matrixWorld" onmouseover="show('Object3D.matrixWorld')" onmouseout="hide()">matrixWorld</a></tt> объекта.<br>
При изменениях в преобразовании родительского или дочернего объекта можно запросить обновление свойства <tt><a href="core.htm#14matrixWorld" onmouseover="show('Object3D.matrixWorld')" onmouseout="hide()">matrixWorld</a></tt> дочернего объекта
вызовом метода <tt><a href="core.htm#14updateMatrixWorld" onmouseover="show('Object3D.updateMatrixWorld')" onmouseout="hide()">updateMatrixWorld</a></tt>.<br><br>

<h4>Вращение и кватернионы</h4>
<div class=note_trans><b>Примечание переводчика:</b> Кватернионы (от лат. quaterni, по четыре) — система гиперкомплексных чисел, образующая векторное пространство размерностью четыре над полем вещественных чисел. Предложены Уильямом Гамильтоном в 1843 году.<a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>Кватернионы удобны для описания изометрий трёх- и четырёхмерного евклидовых пространств, и поэтому получили широкое распространение в механике. Также их используют в вычислительной математике, например, при создании трёхмерной графики.<br>
Кватернионы предоставляют удобное математическое обозначение положения и вращения объектов в пространстве. В сравнении с углами Эйлера, кватернионы позволяют проще комбинировать вращения, а также избежать проблемы, связанной с невозможностью поворота вокруг оси, независимо от совершённого вращения по другим осям (на иллюстрации). В сравнении с матрицами они обладают большей вычислительной устойчивостью и могут быть более эффективными. Кватернионы нашли своё применение в компьютерной графике, робототехнике, навигации, молекулярной динамике.<br>
Проще говоря, кватернион это четырехмерный вектор, т.е. три вектора&nbsp;<tt>x</tt>,&nbsp;<tt>y</tt>,&nbsp;<tt>z</tt> - это положение объекта в трехмерном пространстве, а четвертый вектор (в случае с <em>three.js</em> он обозначается буквой&nbsp;<tt>w</tt>) определяет вращение объекта вокруг какой-либо оси пространства.</div></div>
<em>three.js</em> предоставляет два способа представления трехмерных вращений: <a href="math.htm#5" onmouseover="show('Euler')" onmouseout="hide()">углы Эйлера</a> и <a href="math.htm#13" onmouseover="show('Quaternion')" onmouseout="hide()">кватернионы</a>, а также методы конвертирования между ними.
При расчетах с углами Эйлера возникает проблема, называемая <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%BB%D0%B0%D0%B4%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%80%D0%B0%D0%BC%D0%BE%D0%BA" target="_blank">«шарнирный замок»</a>, когда при определенной конфигурации теряется одна степень свободы (препятствуя повороту объекта вокруг одной оси).
По этой причине, вращение объекта <b>всегда</b> сохраняется в его свойстве <tt><a href="core.htm#14quaternion" onmouseover="show('Object3D.quaternion')" onmouseout="hide()">quaternion</a></tt>.<br>
Предыдущие версии библиотеки включали в себя свойство <tt>useQuaternion</tt>, которое, будучи установленное как <tt>false</tt>, приводило к расчету <a href="core.htm#14matrix" onmouseover="show('Object3D.matrix')" onmouseout="hide()">матрицы</a> объекта из углов Эйлера.
Эта практика устарела - взамен следует использовать метод <tt><a href="core.htm#14setRotationFromEuler" onmouseover="show('Object3D.setRotationFromEuler')" onmouseout="hide()">setRotationFromEuler</a></tt>, который обновит кватернион.<br><br>


<h2 id="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Система анимации</h2>
<h3>Обзор</h3>
В рамках анимационной системы <em>three.js</em> можно анимировать различные свойства модели:
кости (bone) <a href="objects.htm#10" onmouseover="show('SkinnedMesh')" onmouseout="hide()">skinned and rigged model</a>, <a href="core.htm#7morphTargets" onmouseover="show('Geometry.morphTargets')" onmouseout="hide()">цели морфинга (morph targets)</a>,
различные свойства материала (цвета, непрозрачность, логику), видимость и преобразования.
Свойствами анимации могут быть постепенное появление (faded in), постепенное исчезновение (faded out), плавное появление на фоне плавного исчезновения (crossfaded) и деформация (warped).
&#171;Веса&#769;&#187; (weight) и временны&#769;е масштабы (time scales) различных одновременных анимаций как на одном и том же объекте, так и на разных объектах, могут быть изменены независимо друг от друга. Можно синхронизировать различные анимации как на одном и том же объекте, так и на разных объектах.<br><br>
Чтобы достичь всего этого в единственной однородной системе, система анимации three.js <a href="https://github.com/mrdoob/three.js/issues/6881" target="_blank">полностью изменилась в 2015 году</a> (помните об устаревшей информации!), и теперь его архитектура, походит на Unity/Unreal Engine 4.
На этой странице дается краткий обзор основных компонентов этой системы и способов их совместной работы.<br>
<img src="img/animation.png" width="600"><br><br>

<h3>Анимационные клипы Animation Clips</h3>
Если имеется успешно импортированный анимированный 3D объект (неважно имеются ли в нем кости или цели морфинга, или и то и другое) - например, экспортированный из Blender'а с помощью
<a href="https://github.com/mrdoob/three.js/tree/master/utils/exporters/blender/addons/io_three" target="_blank">Blender exporter</a> и загруженный на сцену <em>three.js</em> загрузчиком <a href="loaders.htm#11">JSONLoader</a>, -
то одним из свойств геометрии загружаемой сетки (mesh) должен быть массив, поименованный как "animations", содержащий <a href="animation.htm#2">AnimationClip</a>'ы для данной модели (смотрите ниже список возможных загрузчиков).
If you have successfully imported an animated 3D object (it doesn't matter if it has bones or morph targets or both) - for example exporting it from Blender with the [link:https://github.com/mrdoob/three.js/tree/master/utils/exporters/blender/addons/io_three Blender exporter] and loading it into a three.js scene using [page:JSONLoader] -,
one of the geometry's properties of the loaded mesh should be an array named "animations", containing the [page:AnimationClip AnimationClips] for this model (see a list of possible loaders below).<br><br>
Каждый &#171;AnimationClip&#187; обычно содержит данные для определенной активности объекта. Если сеткой, например является персонаж, то для цикла ходьбы может быть один AnimationClip, для прыжка - второй, третий для уклонения в сторону и так далее.
Each *AnimationClip* usually holds the data for a certain activity of the object. If the mesh is a character, for example, there may be one AnimationClip for a walkcycle, a second for a jump, a third for sidestepping and so on.

<h3>Треки ключевых кадров (Keyframe Tracks)</h3>
Внутри такого &#171;AnimationClip&#187; данные для каждого свойства анимации хранятся в отдельном <a href="animation.htm#6" onmouseover="show('от англ. слов key frame track - трек ключевого кадра')" onmouseout="hide()">KeyframeTrack</a>.
Допустим, персонифицированный объект имеет <a href="objects.htm#9">скелет</a> и один трек ключевого кадра может хранить данные изменений положения кости предплечья во времени, другой трек - данные изменения поворота этой же самой кости,
а третий отслеживать положение, поворот или изменение масштаба другой кости и так далее. Понятно, что AnimationClip может состоять из множества подобных треков.<br><br>
Предположим, что у модели имеются <a href="core.htm#7morphTargets" onmouseover="show('Geometry.morphTargets')" onmouseout="hide()">цели морфинга</a> (например, одна цель морфинга показывает приветливое лицо, а другая - сердитое),
каждый трек хранит сведения о том, как <a href="objects.htm#7morphTargetInfluences" onmouseover="show('Mesh.morphTargetInfluences')" onmouseout="hide()">воздействие (influence)</a> некоторой цели морфинга изменяется во время выполнения клипа.
Assumed the model has [page:Geometry.morphTargets morph targets] (for example one morph target showing a friendly face and another showing an angry face), each track holds the information as to how the [page:Mesh.morphTargetInfluences influence] of a certain morph target changes during the performance of the clip.

<h3>Микшер анимации (Animation Mixer)</h3>
Сохраненные данные формируют только основу анимации - фактическое воспроизведение контролируется <a href="animation.htm#3" onmouseover="show('AnimationMixer')" onmouseout="hide()">AnimationMixer</a>. Можно представить это не только как игрока для анимации, но и как симуляцию аппаратного обеспечения, например, реальной микшерной консоли, которая может одновременно управлять несколькими анимациями, смешивая и объединяя их.
The stored data form only the basis for the animations - actual playback is controlled by the [page:AnimationMixer]. You can imagine this not only as a player for animations, but as a simulation of a hardware like a real mixer console, which can control several animations simultaneously, blending and merging them.

<h3>Действия анимации (Animation Actions)</h3>
Собственно сам &#171;AnimationMixer&#187; имеет только очень мало (общих) свойств и методов, потому что им можно управлять с помощью <a href="animation.htm#1" onmouseover="show('AnimationAction')" onmouseout="hide()">AnimationActions</a>.
The *AnimationMixer* itself has only very few (general) properties and methods, because it can be controlled by the [page:AnimationAction AnimationActions].
Настройкой &#171;AnimationAction&#187; можно определять когда конкретный &#171;AnimationClip&#187; будет воспроизводиться, устанавливаться в паузу или быть остановленным на одном из микшеров, будет ли он повторяться и если будет,
как часто, должен ли он выполняться с затуханием или масштабироваться по времени, и другими дополнительными особенностями вроде кроссфейдинга или синхронизации.
By configuring an *AnimationAction* you can determine when a certain *AnimationClip* shall be played, paused or stopped on one of the mixers, if and how often the clip has to be repeated, whether it shall be performed with a fade or a time scaling, and some additional things, such crossfading or synchronizing.

<h3>Анимация групп объектов</h3>
Если нужно чтобы группа объектов приобрела совместно используемое состояние анимации, можно использовать <a href="animation.htm#4" onmouseover="show('AnimationObjectGroup')" onmouseout="hide()">AnimationObjectGroup</a>.

<h3>Поддерживаемые форматы и загрузчики</h3>
Обратите внимание, не все форматы моделей включают анимацию (в частности OBJ не включает), и что только некоторые загрузчики <em>three.js</em> поддерживают последовательности <a href="animation.htm#2" onmouseover="show('AnimationClip')" onmouseout="hide()">AnimationClip</a>.
Note that not all model formats include animation (OBJ notably does not), and that only some three.js loaders support [page:AnimationClip AnimationClip] sequences. Several that <i>do</i> support this animation type:
<ul><li><a href="loaders.htm#11" onmouseover="show('JSONLoader')" onmouseout="hide()">THREE.JSONLoader</a></li>
<li><a href="loaders.htm#14" onmouseover="show('ObjectLoader')" onmouseout="hide()">THREE.ObjectLoader</a></li>
<li>THREE.BVHLoader</li>
<li>THREE.FBXLoader</li>
<li><a href="examples.htm#3.2" onmouseover="show('GLTFLoader')" onmouseout="hide()">THREE.GLTFLoader</a></li>
<li>THREE.MMDLoader</li>
<li>THREE.SEA3DLoader</li></ul>
Обратите внимание, что в настоящее время 3ds max и Maya не могут экспортировать несколько анимаций (то есть, анимаций, которые не находятся на одном и том же временном промежутке) непосредственно в один файл.
<h4>Пример</h4>
<pre>var mesh;<br>
// Create an AnimationMixer, and get the list of AnimationClip instances
// Создаем AnimationMixer и получаем список экземпляров AnimationClip
var mixer = new THREE.AnimationMixer( mesh );
var clips = mesh.animations;<br>
// Update the mixer on each frame (обновляем микшер в каждом кадре)
function update () {
	mixer.update( deltaSeconds );
}<br>
// Play a specific animation (проигрываем конкретную анимацию)
var clip = THREE.AnimationClip.findByName( clips, 'dance' );
var action = mixer.clipAction( clip );
action.play();<br>
// Play all animations (проигрываем все анимации)
clips.forEach( function ( clip ) {
	mixer.clipAction( clip ).play();
} );</pre>

<br><br>
</body>
</html>
